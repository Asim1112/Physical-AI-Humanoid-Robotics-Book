"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[6781],{6539(n,e,t){t.r(e),t.d(e,{assets:()=>s,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=t(4848),a=t(8453);const i={},r="Bipedal Navigation for Humanoid Robots",l={id:"module-3-isaac/navigation-bipedal",title:"Bipedal Navigation for Humanoid Robots",description:"Overview",source:"@site/docs/module-3-isaac/navigation-bipedal.mdx",sourceDirName:"module-3-isaac",slug:"/module-3-isaac/navigation-bipedal",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-isaac/navigation-bipedal",draft:!1,unlisted:!1,editUrl:"https://github.com/Asim1112/Physical-AI-Humanoid-Robotics-Book/edit/main/frontend/docs/module-3-isaac/navigation-bipedal.mdx",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Perception & Visual SLAM for Humanoid Robots",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-isaac/perception-vslam"},next:{title:"Learning Systems and Sim-to-Real Transfer",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-3-isaac/learning-sim-to-real"}},s={},c=[{value:"Overview",id:"overview",level:2},{value:"Bipedal Navigation Challenges",id:"bipedal-navigation-challenges",level:2},{value:"Balance and Stability",id:"balance-and-stability",level:3},{value:"Terrain Adaptation",id:"terrain-adaptation",level:3},{value:"Computational Complexity",id:"computational-complexity",level:3},{value:"Navigation Architecture for Bipedal Robots",id:"navigation-architecture-for-bipedal-robots",level:2},{value:"Global Path Planning for Bipedal Robots",id:"global-path-planning-for-bipedal-robots",level:2},{value:"Topological Navigation",id:"topological-navigation",level:3},{value:"Bipedal-Specific Path Planning",id:"bipedal-specific-path-planning",level:3},{value:"Local Path Planning and Obstacle Avoidance",id:"local-path-planning-and-obstacle-avoidance",level:2},{value:"Dynamic Window Approach for Bipedal Robots",id:"dynamic-window-approach-for-bipedal-robots",level:3},{value:"Footstep Planning",id:"footstep-planning",level:2},{value:"Stability-Based Footstep Planning",id:"stability-based-footstep-planning",level:3},{value:"Motion Generation for Bipedal Locomotion",id:"motion-generation-for-bipedal-locomotion",level:2},{value:"Center of Mass Trajectory Planning",id:"center-of-mass-trajectory-planning",level:3},{value:"Swing Foot Trajectory Generation",id:"swing-foot-trajectory-generation",level:3},{value:"Balance Control Integration",id:"balance-control-integration",level:2},{value:"Whole-Body Balance Control",id:"whole-body-balance-control",level:3},{value:"NVIDIA Isaac Navigation Integration",id:"nvidia-isaac-navigation-integration",level:2},{value:"Isaac Navigation Stack Configuration",id:"isaac-navigation-stack-configuration",level:3}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"bipedal-navigation-for-humanoid-robots",children:"Bipedal Navigation for Humanoid Robots"}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"Bipedal navigation presents unique challenges compared to wheeled or tracked robot navigation. Humanoid robots must maintain dynamic balance while navigating, plan footsteps carefully, and coordinate complex multi-joint movements. This chapter explores specialized navigation algorithms and techniques designed specifically for bipedal locomotion using NVIDIA Isaac platform capabilities."}),"\n",(0,o.jsx)(e.h2,{id:"bipedal-navigation-challenges",children:"Bipedal Navigation Challenges"}),"\n",(0,o.jsx)(e.p,{children:"Unlike wheeled robots, humanoid robots face several unique navigation challenges:"}),"\n",(0,o.jsx)(e.h3,{id:"balance-and-stability",children:"Balance and Stability"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Balance"}),": Maintaining center of mass within support polygon"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Step Planning"}),": Carefully planning foot placements for stability"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Gait Transitions"}),": Smoothly transitioning between different walking gaits"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Systems"}),": Emergency balance recovery when stability is compromised"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"terrain-adaptation",children:"Terrain Adaptation"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Uneven Surfaces"}),": Navigating stairs, slopes, and irregular terrain"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Step Height Variations"}),": Adapting to different step heights and obstacles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Surface Compliance"}),": Handling soft, slippery, or unstable surfaces"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multi-contact Planning"}),": Planning for hand support when needed"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"computational-complexity",children:"Computational Complexity"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"High DOF Control"}),": Coordinating 20+ joints for stable locomotion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Real-time Requirements"}),": Maintaining balance at 100+ Hz control rates"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multi-objective Optimization"}),": Balancing speed, stability, and energy efficiency"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"navigation-architecture-for-bipedal-robots",children:"Navigation Architecture for Bipedal Robots"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   GLOBAL        \u2502    \u2502   LOCAL         \u2502    \u2502   FOOTSTEP      \u2502\n\u2502   PLANNING      \u2502\u2500\u2500\u2500\u25ba\u2502   PLANNING      \u2502\u2500\u2500\u2500\u25ba\u2502   PLANNING      \u2502\n\u2502                 \u2502    \u2502                 \u2502    \u2502                 \u2502\n\u2502 \u2022 Topological   \u2502    \u2502 \u2022 Collision     \u2502    \u2502 \u2022 Foot placement\u2502\n\u2502   Maps          \u2502    \u2502   Avoidance     \u2502    \u2502 \u2022 Swing planning\u2502\n\u2502 \u2022 Path Finding  \u2502    \u2502 \u2022 Dynamic       \u2502    \u2502 \u2022 Balance       \u2502\n\u2502 \u2022 Waypoint      \u2502    \u2502   Obstacles     \u2502    \u2502   Constraints   \u2502\n\u2502   Generation    \u2502    \u2502 \u2022 Velocity      \u2502    \u2502 \u2022 Gait Patterns \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2502   Profiling     \u2502    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n                              \u2502                         \u25bc\n                              \u25bc                  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n                       \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510       \u2502   MOTION        \u2502\n                       \u2502   TRAJECTORY    \u2502\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502   GENERATION    \u2502\n                       \u2502   GENERATION    \u2502       \u2502                 \u2502\n                       \u2502                 \u2502       \u2502 \u2022 Joint         \u2502\n                       \u2502 \u2022 Velocity      \u2502       \u2502   Trajectories  \u2502\n                       \u2502   Profiles      \u2502       \u2502 \u2022 Balance       \u2502\n                       \u2502 \u2022 Timing        \u2502       \u2502   Control       \u2502\n                       \u2502   Constraints   \u2502       \u2502 \u2022 Swing Control \u2502\n                       \u2502 \u2022 Smoothness    \u2502       \u2502 \u2022 Landing       \u2502\n                       \u2502   Optimization  \u2502       \u2502   Control       \u2502\n                       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,o.jsx)(e.h2,{id:"global-path-planning-for-bipedal-robots",children:"Global Path Planning for Bipedal Robots"}),"\n",(0,o.jsx)(e.h3,{id:"topological-navigation",children:"Topological Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Bipedal robots often use topological maps that represent navigable locations and connections:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class TopologicalMap:\n    def __init__(self):\n        self.nodes = {}  # Waypoints with stability information\n        self.edges = {}  # Navigable connections\n        self.stability_map = {}  # Stability scores for locations\n\n    def add_waypoint(self, name, pose, stability_score):\n        """Add a stable waypoint to the topological map."""\n        self.nodes[name] = {\n            \'pose\': pose,\n            \'stability_score\': stability_score,\n            \'footstep_constraints\': self.calculate_footstep_constraints(pose)\n        }\n\n    def find_stable_path(self, start, goal):\n        """Find path through most stable waypoints."""\n        # Use A* with stability as heuristic\n        def stability_heuristic(node):\n            return self.nodes[node][\'stability_score\']\n\n        return self.astar_with_stability(start, goal, stability_heuristic)\n'})}),"\n",(0,o.jsx)(e.h3,{id:"bipedal-specific-path-planning",children:"Bipedal-Specific Path Planning"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nfrom scipy.spatial import KDTree\n\nclass BipedalPathPlanner:\n    def __init__(self):\n        self.occupancy_grid = None\n        self.stability_map = None\n        self.step_constraints = {\'max_step_width\': 0.3, \'max_step_height\': 0.15}\n\n    def plan_stable_path(self, start_pose, goal_pose, robot_radius=0.3):\n        """Plan path considering bipedal stability constraints."""\n        # Inflate obstacles based on robot\'s footstep requirements\n        inflated_grid = self.inflate_for_footsteps(robot_radius)\n\n        # Plan path using RRT* or similar algorithm\n        path = self.rrt_star_with_stability(start_pose, goal_pose, inflated_grid)\n\n        # Smooth path for bipedal locomotion\n        smoothed_path = self.smooth_bipedal_path(path)\n\n        return smoothed_path\n\n    def inflate_for_footsteps(self, robot_radius):\n        """Inflate obstacles considering footstep placement requirements."""\n        # Create larger safety margin for bipedal navigation\n        safety_margin = robot_radius + self.step_constraints[\'max_step_width\']\n        return self.inflate_occupancy_grid(safety_margin)\n\n    def smooth_bipedal_path(self, path):\n        """Smooth path for natural bipedal movement."""\n        # Apply smoothing that maintains footstep feasibility\n        smoothed = []\n        for i in range(len(path)):\n            if i == 0 or i == len(path) - 1:\n                smoothed.append(path[i])\n            else:\n                # Consider stability of intermediate points\n                smoothed_point = self.optimize_for_stability(path[i-1], path[i], path[i+1])\n                smoothed.append(smoothed_point)\n        return np.array(smoothed)\n'})}),"\n",(0,o.jsx)(e.h2,{id:"local-path-planning-and-obstacle-avoidance",children:"Local Path Planning and Obstacle Avoidance"}),"\n",(0,o.jsx)(e.h3,{id:"dynamic-window-approach-for-bipedal-robots",children:"Dynamic Window Approach for Bipedal Robots"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class BipedalDWA:\n    def __init__(self):\n        self.max_vel = 0.5  # Conservative for stability\n        self.max_acc = 0.5\n        self.dt = 0.1\n        self.prediction_time = 2.0\n        self.balance_threshold = 0.1  # Maximum CoM deviation\n\n    def calculate_velocities(self, robot_state, goal, obstacles):\n        """Calculate safe velocities considering balance constraints."""\n        # Generate velocity samples\n        v_samples = np.linspace(0, self.max_vel, 10)\n        w_samples = np.linspace(-0.5, 0.5, 10)\n\n        best_score = -float(\'inf\')\n        best_vel = (0, 0)\n\n        for v in v_samples:\n            for w in w_samples:\n                # Simulate trajectory\n                trajectory = self.predict_trajectory(robot_state, v, w)\n\n                # Evaluate for safety, goal, and balance\n                score = self.evaluate_trajectory(trajectory, goal, obstacles)\n\n                if score > best_score:\n                    best_score = score\n                    best_vel = (v, w)\n\n        return best_vel\n\n    def evaluate_trajectory(self, trajectory, goal, obstacles):\n        """Evaluate trajectory considering balance and safety."""\n        # Safety score (distance to obstacles)\n        safety_score = self.calculate_safety_score(trajectory, obstacles)\n\n        # Goal score (closeness to target)\n        goal_score = self.calculate_goal_score(trajectory, goal)\n\n        # Balance score (stability during movement)\n        balance_score = self.calculate_balance_score(trajectory)\n\n        # Weighted combination\n        total_score = (0.3 * safety_score +\n                      0.4 * goal_score +\n                      0.3 * balance_score)\n\n        return total_score\n\n    def calculate_balance_score(self, trajectory):\n        """Calculate score based on balance during trajectory."""\n        balance_score = 0\n        for pose in trajectory:\n            # Calculate center of mass position relative to feet\n            com_pos = self.calculate_com_position(pose)\n            support_polygon = self.calculate_support_polygon(pose)\n\n            # Distance to support polygon boundary\n            stability_margin = self.distance_to_support_boundary(com_pos, support_polygon)\n\n            # Higher score for better stability\n            balance_score += max(0, stability_margin - self.balance_threshold)\n\n        return balance_score / len(trajectory) if trajectory else 0\n'})}),"\n",(0,o.jsx)(e.h2,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,o.jsx)(e.h3,{id:"stability-based-footstep-planning",children:"Stability-Based Footstep Planning"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class FootstepPlanner:\n    def __init__(self):\n        self.step_width = 0.2  # Distance between feet\n        self.step_length = 0.3  # Step length\n        self.max_step_height = 0.15  # Max step over height\n        self.support_polygon_margin = 0.05\n\n    def plan_footsteps(self, path, start_pose, goal_pose):\n        \"\"\"Plan stable footsteps along the path.\"\"\"\n        footsteps = []\n\n        # Start with current foot positions\n        left_foot, right_foot = self.get_initial_foot_positions(start_pose)\n        footsteps.append(('left', left_foot))\n        footsteps.append(('right', right_foot))\n\n        # Plan footsteps along path\n        current_left = left_foot\n        current_right = right_foot\n        current_support = 'left'  # Right foot will move next\n\n        for i, path_point in enumerate(path[1:]):\n            # Calculate next foot position based on path direction\n            if current_support == 'left':\n                # Move right foot\n                next_right = self.calculate_next_foot_position(\n                    path_point, current_left, 'right'\n                )\n                footsteps.append(('right', next_right))\n                current_right = next_right\n                current_support = 'right'\n            else:\n                # Move left foot\n                next_left = self.calculate_next_foot_position(\n                    path_point, current_right, 'left'\n                )\n                footsteps.append(('left', next_left))\n                current_left = next_left\n                current_support = 'left'\n\n        return footsteps\n\n    def calculate_next_foot_position(self, target_pos, support_foot, swing_foot):\n        \"\"\"Calculate optimal next position for swing foot.\"\"\"\n        # Calculate direction from support foot to target\n        direction = target_pos[:2] - support_foot[:2]\n        direction_norm = np.linalg.norm(direction)\n\n        if direction_norm > 0:\n            direction_unit = direction / direction_norm\n        else:\n            direction_unit = np.array([1, 0])  # Default direction\n\n        # Calculate next foot position\n        step_distance = min(self.step_length, direction_norm)\n        next_pos = support_foot[:2] + direction_unit * step_distance\n\n        # Add lateral offset for stability\n        if swing_foot == 'left':\n            lateral_offset = np.array([-self.step_width/2, 0])\n        else:\n            lateral_offset = np.array([self.step_width/2, 0])\n\n        # Rotate lateral offset based on movement direction\n        rotation_matrix = np.array([\n            [direction_unit[0], -direction_unit[1]],\n            [direction_unit[1], direction_unit[0]]\n        ])\n        lateral_offset = rotation_matrix @ lateral_offset\n\n        final_pos = np.array([next_pos[0] + lateral_offset[0],\n                             next_pos[1] + lateral_offset[1],\n                             target_pos[2]])  # Maintain height\n\n        return final_pos\n"})}),"\n",(0,o.jsx)(e.h2,{id:"motion-generation-for-bipedal-locomotion",children:"Motion Generation for Bipedal Locomotion"}),"\n",(0,o.jsx)(e.h3,{id:"center-of-mass-trajectory-planning",children:"Center of Mass Trajectory Planning"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class CoMTrajectoryGenerator:\n    def __init__(self):\n        self.zmp_reference = 0.0  # Zero Moment Point reference\n        self.com_height = 0.8     # Desired CoM height\n        self.walk_frequency = 1.0 # Walking frequency (Hz)\n\n    def generate_com_trajectory(self, footsteps, dt=0.01):\n        """Generate CoM trajectory from footsteps using ZMP planning."""\n        # Calculate ZMP trajectory from footsteps\n        zmp_trajectory = self.calculate_zmp_from_footsteps(footsteps)\n\n        # Generate CoM trajectory using inverted pendulum model\n        com_trajectory = self.integrate_zmp_to_com(zmp_trajectory, dt)\n\n        return com_trajectory\n\n    def calculate_zmp_from_footsteps(self, footsteps):\n        """Calculate ZMP trajectory from footstep sequence."""\n        zmp_points = []\n\n        for i, (foot, pose) in enumerate(footsteps):\n            # ZMP should be near the center of the support foot\n            zmp_point = self.calculate_zmp_for_foot(foot, pose)\n            zmp_points.append(zmp_point)\n\n        # Interpolate between footsteps for smooth ZMP trajectory\n        zmp_trajectory = self.interpolate_zmp_trajectory(zmp_points)\n\n        return zmp_trajectory\n\n    def integrate_zmp_to_com(self, zmp_trajectory, dt):\n        """Integrate ZMP to generate CoM trajectory using inverted pendulum."""\n        # Inverted pendulum model: CoM acceleration = g/h * (CoM - ZMP)\n        # where g is gravity and h is CoM height\n\n        g = 9.81  # gravity\n        h = self.com_height\n\n        com_trajectory = []\n        com_pos = np.array([0.0, 0.0, self.com_height])  # Start position\n        com_vel = np.array([0.0, 0.0, 0.0])  # Start velocity\n\n        for zmp in zmp_trajectory:\n            # Calculate CoM acceleration\n            com_acc = (g / h) * (com_pos[:2] - zmp)\n            com_acc = np.append(com_acc, 0)  # No vertical acceleration for now\n\n            # Integrate to get velocity and position\n            com_vel += com_acc * dt\n            com_pos += com_vel * dt\n\n            com_trajectory.append(com_pos.copy())\n\n        return np.array(com_trajectory)\n'})}),"\n",(0,o.jsx)(e.h3,{id:"swing-foot-trajectory-generation",children:"Swing Foot Trajectory Generation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class SwingFootTrajectory:\n    def __init__(self):\n        self.step_height = 0.1  # Height to lift foot during swing\n        self.swing_duration = 0.5  # Duration of swing phase\n\n    def generate_swing_trajectory(self, start_pos, end_pos, duration=None):\n        """Generate smooth swing trajectory for foot movement."""\n        if duration is None:\n            duration = self.swing_duration\n\n        # Calculate intermediate points\n        mid_point = (start_pos + end_pos) / 2\n        mid_point[2] += self.step_height  # Lift foot at midpoint\n\n        # Generate trajectory using cubic interpolation\n        t = np.linspace(0, duration, int(duration * 100))  # 100 Hz trajectory\n        trajectory = []\n\n        for time_step in t:\n            # Cubic interpolation for smooth motion\n            progress = time_step / duration\n            pos = self.cubic_interpolation(start_pos, mid_point, end_pos, progress)\n            trajectory.append(pos)\n\n        return np.array(trajectory)\n\n    def cubic_interpolation(self, start, mid, end, t):\n        """Cubic interpolation for smooth trajectory generation."""\n        # Use cubic Bezier curve for smooth interpolation\n        # B(t) = (1-t)\xb3P\u2080 + 3(1-t)\xb2tP\u2081 + 3(1-t)t\xb2P\u2082 + t\xb3P\u2083\n        # For our case: P\u2080=start, P\u2081=control point 1, P\u2082=control point 2, P\u2083=end\n\n        # Calculate control points for smooth lifting and landing\n        control1 = start + (mid - start) * 0.3\n        control2 = mid + (end - mid) * 0.7\n\n        result = ((1-t)**3) * start + \\\n                 3 * ((1-t)**2) * t * control1 + \\\n                 3 * (1-t) * (t**2) * control2 + \\\n                 (t**3) * end\n\n        return result\n'})}),"\n",(0,o.jsx)(e.h2,{id:"balance-control-integration",children:"Balance Control Integration"}),"\n",(0,o.jsx)(e.h3,{id:"whole-body-balance-control",children:"Whole-Body Balance Control"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class WholeBodyBalanceController:\n    def __init__(self):\n        self.com_controller = self.initialize_com_controller()\n        self.foot_controller = self.initialize_foot_controller()\n        self.arm_controller = self.initialize_arm_controller()\n\n    def calculate_balance_control(self, desired_com, current_state, support_foot):\n        \"\"\"Calculate whole-body control for balance maintenance.\"\"\"\n        # Calculate CoM error\n        com_error = desired_com - current_state['com_position']\n\n        # Generate CoM control command\n        com_control = self.com_controller.update(com_error)\n\n        # Calculate foot placement adjustments\n        foot_control = self.calculate_foot_adjustment(\n            current_state, support_foot, com_control\n        )\n\n        # Calculate arm movements for balance\n        arm_control = self.calculate_arm_balance(\n            com_error, current_state['orientation']\n        )\n\n        # Combine all controls\n        control_commands = {\n            'com': com_control,\n            'feet': foot_control,\n            'arms': arm_control\n        }\n\n        return control_commands\n\n    def calculate_foot_adjustment(self, state, support_foot, com_control):\n        \"\"\"Calculate foot placement adjustments for balance.\"\"\"\n        # Calculate required foot movement to maintain ZMP\n        required_zmp = self.calculate_required_zmp(com_control)\n        current_zmp = self.calculate_current_zmp(state)\n\n        # Calculate foot adjustment needed\n        foot_adjustment = self.inverse_zmp_to_foot(required_zmp, current_zmp, support_foot)\n\n        return foot_adjustment\n\n    def calculate_arm_balance(self, com_error, orientation):\n        \"\"\"Calculate arm movements to assist with balance.\"\"\"\n        # Calculate required arm torques based on CoM error\n        # Arms can provide additional stability by moving in opposite direction\n\n        # Map CoM error to arm movements\n        arm_commands = {\n            'left_arm': self.map_com_error_to_arm(com_error, 'left'),\n            'right_arm': self.map_com_error_to_arm(com_error, 'right')\n        }\n\n        return arm_commands\n"})}),"\n",(0,o.jsx)(e.h2,{id:"nvidia-isaac-navigation-integration",children:"NVIDIA Isaac Navigation Integration"}),"\n",(0,o.jsx)(e.h3,{id:"isaac-navigation-stack-configuration",children:"Isaac Navigation Stack Configuration"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Isaac Navigation configuration for bipedal robots\nbt_navigator:\n  ros__parameters:\n    use_sim_time: True\n    global_frame: map\n    robot_base_frame: base_link\n    odom_topic: /odom\n    bt_loop_duration: 10\n    default_server_timeout: 20\n    enable_groot_monitoring: True\n    groot_zmq_publisher_port: 1666\n    groot_zmq_server_port: 1667\n    # Bipedal-specific parameters\n    max_linear_speed: 0.3\n    max_angular_speed: 0.3\n    balance_threshold: 0.1\n\ncontroller_server:\n  ros__parameters:\n    use_sim_time: True\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.001\n    min_y_velocity_threshold: 0.5\n    min_theta_velocity_threshold: 0.001\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_steps: 50\n      model_dt: 0.05\n      batch_size: 1000\n      vx_std: 0.2\n      vy_std: 0.05\n      wz_std: 0.3\n      vx_max: 0.3  # Conservative for bipedal\n      vx_min: -0.1\n      vy_max: 0.1\n      wz_max: 0.3\n      xy_goal_tolerance: 0.1\n      yaw_goal_tolerance: 0.1\n      motion_model: "DiffDrive"\n      # Bipedal-specific cost parameters\n      balance_cost_weight: 10.0\n      step_cost_weight: 5.0\n      smoothness_cost_weight: 2.0\n\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 5.0\n      publish_frequency: 2.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: True\n      rolling_window: True\n      width: 6\n      height: 6\n      resolution: 0.05  # Higher resolution for footstep planning\n      robot_radius: 0.3\n      # Bipedal-specific inflation\n      inflation_radius: 0.5\n      cost_scaling_factor: 3.0\n'})})]})}function d(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453(n,e,t){t.d(e,{R:()=>r,x:()=>l});var o=t(6540);const a={},i=o.createContext(a);function r(n){const e=o.useContext(i);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),o.createElement(i.Provider,{value:e},n.children)}}}]);