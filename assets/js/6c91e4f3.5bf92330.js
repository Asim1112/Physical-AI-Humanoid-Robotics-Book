"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[9794],{5871(n,e,i){i.r(e),i.d(e,{assets:()=>m,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>d,toc:()=>u});var t=i(4848),s=i(8453),o=i(4252),r=i(1470),a=i(9365);const l={title:"ROS 2 Integration",description:"Learn about integrating simulation environments with ROS 2 for humanoid robotics",tags:["ros2","simulation","integration","robotics","gazebo","unity"],sidebar_label:"ROS 2 Integration",sidebar_position:5,keywords:["ros2","simulation","integration","robotics"],toc_min_heading_level:2,toc_max_heading_level:4},c="ROS 2 Integration",d={id:"module-2-digital-twin/ros2-integration",title:"ROS 2 Integration",description:"Learn about integrating simulation environments with ROS 2 for humanoid robotics",source:"@site/docs/module-2-digital-twin/ros2-integration.mdx",sourceDirName:"module-2-digital-twin",slug:"/module-2-digital-twin/ros2-integration",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/ros2-integration",draft:!1,unlisted:!1,editUrl:"https://github.com/Asim1112/Physical-AI-Humanoid-Robotics-Book/edit/main/frontend/docs/module-2-digital-twin/ros2-integration.mdx",tags:[{label:"ros2",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/ros-2"},{label:"simulation",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/simulation"},{label:"integration",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/integration"},{label:"robotics",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/robotics"},{label:"gazebo",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/gazebo"},{label:"unity",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/unity"}],version:"current",sidebarPosition:5,frontMatter:{title:"ROS 2 Integration",description:"Learn about integrating simulation environments with ROS 2 for humanoid robotics",tags:["ros2","simulation","integration","robotics","gazebo","unity"],sidebar_label:"ROS 2 Integration",sidebar_position:5,keywords:["ros2","simulation","integration","robotics"],toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"tutorialSidebar",previous:{title:"Unity Visualization",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/unity-visualization"},next:{title:"Gazebo Simulation Integration with ROS 2",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-2-digital-twin/gazebo-integration"}},m={},u=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Deep Explanation",id:"deep-explanation",level:2},{value:"Simulation Integration Architecture",id:"simulation-integration-architecture",level:3},{value:"Gazebo-ROS Bridge",id:"gazebo-ros-bridge",level:4},{value:"Unity-ROS Bridge",id:"unity-ros-bridge",level:4},{value:"Communication Patterns in Simulation",id:"communication-patterns-in-simulation",level:3},{value:"Sensor Data Flow",id:"sensor-data-flow",level:4},{value:"Control Command Flow",id:"control-command-flow",level:4},{value:"State and Configuration",id:"state-and-configuration",level:4},{value:"Gazebo-ROS Integration Components",id:"gazebo-ros-integration-components",level:3},{value:"Sensor Plugins",id:"sensor-plugins",level:4},{value:"Actuator Plugins",id:"actuator-plugins",level:4},{value:"Model Plugins",id:"model-plugins",level:4},{value:"Unity-ROS Integration Components",id:"unity-ros-integration-components",level:3},{value:"Message Handling",id:"message-handling",level:4},{value:"Visualization Mapping",id:"visualization-mapping",level:4},{value:"Simulation Fidelity Considerations",id:"simulation-fidelity-considerations",level:3},{value:"Accuracy vs. Performance",id:"accuracy-vs-performance",level:4},{value:"Realism vs. Stability",id:"realism-vs-stability",level:4},{value:"Integration Validation",id:"integration-validation",level:3},{value:"Sensor Data Validation",id:"sensor-data-validation",level:4},{value:"Control Response Validation",id:"control-response-validation",level:4},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Gazebo-ROS Integration Launch File",id:"example-1-gazebo-ros-integration-launch-file",level:3},{value:"Example 2: Simulation Integration Node",id:"example-2-simulation-integration-node",level:3},{value:"Exercises and Checkpoints",id:"exercises-and-checkpoints",level:2},{value:"Exercise 1: Simulation Integration Architecture",id:"exercise-1-simulation-integration-architecture",level:3},{value:"Exercise 2: Gazebo-ROS Integration Implementation",id:"exercise-2-gazebo-ros-integration-implementation",level:3},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:3},{value:"Summary and Key Takeaways",id:"summary-and-key-takeaways",level:2},{value:"Key Concepts Recap",id:"key-concepts-recap",level:3},{value:"Practical Applications",id:"practical-applications",level:3},{value:"Next Steps",id:"next-steps",level:3},{value:"Common Mistakes and Troubleshooting",id:"common-mistakes-and-troubleshooting",level:3},{value:"References and Resources",id:"references-and-resources",level:3}];function g(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n","\n","\n",(0,t.jsx)(o.A,{toc:u}),"\n",(0,t.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,t.jsx)(e.p,{children:"ROS 2 integration is the cornerstone of effective simulation for humanoid robotics, enabling seamless communication between simulation environments and robot control systems. This chapter explores how to connect Gazebo and Unity simulations with ROS 2, creating a unified system where simulated robots can be controlled using the same interfaces as real robots, and where behaviors developed in simulation can be transferred to physical systems."}),"\n",(0,t.jsx)(e.p,{children:"The integration involves multiple layers of communication, from low-level sensor simulation and actuator control to high-level planning and coordination. We'll examine the architecture, tools, and best practices for creating robust simulation-integration systems that accelerate robot development while maintaining the fidelity needed for effective sim-to-real transfer."}),"\n",(0,t.jsx)(e.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand the architecture of ROS 2 simulation integration systems"}),"\n",(0,t.jsx)(e.li,{children:"Implement Gazebo-ROS 2 communication for physics simulation"}),"\n",(0,t.jsx)(e.li,{children:"Connect Unity visualization with ROS 2 control systems"}),"\n",(0,t.jsx)(e.li,{children:"Create bidirectional data flow between simulation and control"}),"\n",(0,t.jsx)(e.li,{children:"Validate simulation fidelity against real robot behavior"}),"\n",(0,t.jsx)(e.li,{children:"Optimize integration for performance and reliability"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understanding of ROS 2 communication patterns from Module 1"}),"\n",(0,t.jsx)(e.li,{children:"Knowledge of Gazebo physics from the previous chapter"}),"\n",(0,t.jsx)(e.li,{children:"Basic understanding of Unity-ROS integration concepts"}),"\n",(0,t.jsx)(e.li,{children:"Familiarity with robot control systems and sensor data processing"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"deep-explanation",children:"Deep Explanation"}),"\n",(0,t.jsx)(e.h3,{id:"simulation-integration-architecture",children:"Simulation Integration Architecture"}),"\n",(0,t.jsx)(e.p,{children:"The integration between simulation environments and ROS 2 follows a standardized architecture:"}),"\n",(0,t.jsx)(e.h4,{id:"gazebo-ros-bridge",children:"Gazebo-ROS Bridge"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"gazebo_ros_pkgs"})," and newer ",(0,t.jsx)(e.code,{children:"ros_gz"})," packages provide the bridge between Gazebo simulation and ROS 2:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"gazebo_ros"}),": Legacy bridge for Gazebo Classic"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ros_gz"}),": Modern bridge for Ignition Gazebo/Harmonic"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor plugins"}),": Publish sensor data to ROS topics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Actuator plugins"}),": Subscribe to ROS topics for motor control"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Model plugins"}),": Handle custom robot behaviors in simulation"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"unity-ros-bridge",children:"Unity-ROS Bridge"}),"\n",(0,t.jsx)(e.p,{children:"The Unity-ROS connection typically uses:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS#"}),": .NET-based ROS client for Unity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"TCP/UDP communication"}),": Network-based message passing"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Custom message handling"}),": Serialization/deserialization of ROS messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Asset integration"}),": Unity components for ROS communication"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"communication-patterns-in-simulation",children:"Communication Patterns in Simulation"}),"\n",(0,t.jsx)(e.p,{children:"Simulation integration uses various ROS 2 communication patterns:"}),"\n",(0,t.jsx)(e.h4,{id:"sensor-data-flow",children:"Sensor Data Flow"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Publishers"}),": Simulation environment publishes sensor data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Message types"}),": sensor_msgs for cameras, IMU, LiDAR, etc."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"QoS settings"}),": Appropriate for real-time sensor data"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Synchronization"}),": Coordination between multiple sensors"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"control-command-flow",children:"Control Command Flow"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Subscribers"}),": Simulation environment subscribes to control commands"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint control"}),": Position, velocity, or effort control interfaces"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Trajectory execution"}),": Action-based trajectory following"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safety monitoring"}),": Command validation and limits"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"state-and-configuration",children:"State and Configuration"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Services"}),": Robot state queries and configuration changes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Parameters"}),": Runtime configuration of simulation properties"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Actions"}),": Long-running processes like navigation or manipulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Transforms"}),": Coordinate frame relationships (TF)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"gazebo-ros-integration-components",children:"Gazebo-ROS Integration Components"}),"\n",(0,t.jsx)(e.h4,{id:"sensor-plugins",children:"Sensor Plugins"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo sensor plugins bridge simulated sensors to ROS topics:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Camera plugins"}),": Publish sensor_msgs/Image messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"IMU plugins"}),": Publish sensor_msgs/Imu messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"LiDAR plugins"}),": Publish sensor_msgs/LaserScan or sensor_msgs/PointCloud2"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Force/Torque plugins"}),": Publish geometry_msgs/WrenchStamped"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"actuator-plugins",children:"Actuator Plugins"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo actuator plugins bridge ROS commands to simulated joints:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint position controllers"}),": Subscribe to position commands"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint velocity controllers"}),": Subscribe to velocity commands"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint effort controllers"}),": Subscribe to effort/torque commands"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ROS 2 Control"}),": Modern control framework integration"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"model-plugins",children:"Model Plugins"}),"\n",(0,t.jsx)(e.p,{children:"Custom plugins for robot-specific behaviors:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Custom controllers"}),": Robot-specific simulation logic"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor processing"}),": On-board simulation of sensor processing"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Communication simulation"}),": Network delay and reliability modeling"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Failure simulation"}),": Component failure and recovery simulation"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"unity-ros-integration-components",children:"Unity-ROS Integration Components"}),"\n",(0,t.jsx)(e.h4,{id:"message-handling",children:"Message Handling"}),"\n",(0,t.jsx)(e.p,{children:"Unity handles ROS messages through the ROS# library:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Serialization"}),": Converting between Unity types and ROS messages"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Deserialization"}),": Converting ROS messages to Unity objects"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Message validation"}),": Ensuring message integrity"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Connection management"}),": Handling network communication"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"visualization-mapping",children:"Visualization Mapping"}),"\n",(0,t.jsx)(e.p,{children:"Mapping between ROS coordinate systems and Unity:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Coordinate transformation"}),": ROS (X-forward, Y-left, Z-up) to Unity (X-right, Y-up, Z-forward)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unit conversion"}),": Meters to Unity units"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Timing synchronization"}),": Aligning simulation and visualization clocks"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Data interpolation"}),": Smoothing for visualization purposes"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"simulation-fidelity-considerations",children:"Simulation Fidelity Considerations"}),"\n",(0,t.jsx)(e.p,{children:"Effective simulation integration must balance:"}),"\n",(0,t.jsx)(e.h4,{id:"accuracy-vs-performance",children:"Accuracy vs. Performance"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Physics accuracy"}),": Detailed collision models vs. performance"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Sensor simulation"}),": Realistic noise models vs. computational cost"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Network latency"}),": Real-world communication delays vs. responsiveness"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Update rates"}),": High-frequency updates vs. system load"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"realism-vs-stability",children:"Realism vs. Stability"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Realistic parameters"}),": Accurate simulation vs. numerical stability"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Contact modeling"}),": Complex interactions vs. simulation stability"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Control response"}),": Accurate dynamics vs. controller stability"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Environmental effects"}),": Realistic conditions vs. simulation robustness"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"integration-validation",children:"Integration Validation"}),"\n",(0,t.jsx)(e.p,{children:"Validating simulation integration involves:"}),"\n",(0,t.jsx)(e.h4,{id:"sensor-data-validation",children:"Sensor Data Validation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Comparing simulated vs. real sensor data"}),"\n",(0,t.jsx)(e.li,{children:"Validating noise characteristics"}),"\n",(0,t.jsx)(e.li,{children:"Checking timing and synchronization"}),"\n",(0,t.jsx)(e.li,{children:"Verifying field of view and range limits"}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"control-response-validation",children:"Control Response Validation"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Comparing command-to-response times"}),"\n",(0,t.jsx)(e.li,{children:"Validating joint limits and constraints"}),"\n",(0,t.jsx)(e.li,{children:"Checking control accuracy and precision"}),"\n",(0,t.jsx)(e.li,{children:"Verifying safety systems behavior"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,t.jsx)(e.h3,{id:"example-1-gazebo-ros-integration-launch-file",children:"Example 1: Gazebo-ROS Integration Launch File"}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(a.A,{value:"launch_file",label:"Launch File",default:!0,children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<launch>\n  \x3c!-- Arguments for configuration --\x3e\n  <arg name="world_name" default="humanoid_test_world"/>\n  <arg name="model_name" default="simple_humanoid"/>\n  <arg name="use_sim_time" default="true"/>\n  <arg name="headless" default="false"/>\n\n  \x3c!-- Gazebo server --\x3e\n  <include file="$(find-pkg-share gazebo_ros)/launch/gazebo.launch.py">\n    <arg name="world" value="$(find-pkg-share my_robot_gazebo)/worlds/$(var world_name).sdf"/>\n    <arg name="headless" value="$(var headless)"/>\n    <arg name="verbose" value="false"/>\n  </include>\n\n  \x3c!-- Robot state publisher --\x3e\n  <node pkg="robot_state_publisher" exec="robot_state_publisher" name="robot_state_publisher">\n    <param name="robot_description" value="$(find-pkg-share my_robot_description)/urdf/$(var model_name).urdf"/>\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n  \x3c!-- Spawn robot in Gazebo --\x3e\n  <node pkg="gazebo_ros" exec="spawn_entity.py" name="spawn_robot">\n    <param name="world_name" value="$(var world_name)"/>\n    <param name="robot_name" value="$(var model_name)"/>\n    <param name="robot_namespace" value=""/>\n    <param name="x" value="0.0"/>\n    <param name="y" value="0.0"/>\n    <param name="z" value="1.0"/>\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n  \x3c!-- ROS 2 Control --\x3e\n  <node pkg="controller_manager" exec="ros2_control_node" name="ros2_control_node">\n    <param name="robot_description" value="$(find-pkg-share my_robot_description)/urdf/$(var model_name).urdf"/>\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n  \x3c!-- Load controllers --\x3e\n  <node pkg="controller_manager" exec="spawner" name="joint_state_broadcaster_spawner" args="joint_state_broadcaster"/>\n  <node pkg="controller_manager" exec="spawner" name="arm_controller_spawner" args="arm_controller"/>\n  <node pkg="controller_manager" exec="spawner" name="leg_controller_spawner" args="leg_controller"/>\n\n  \x3c!-- Simulation-specific nodes --\x3e\n  <node pkg="my_robot_sim" exec="contact_analyzer" name="contact_analyzer">\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n  <node pkg="my_robot_sim" exec="physics_validator" name="physics_validator">\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n</launch>\n'})})}),(0,t.jsx)(a.A,{value:"ros2_control_config",label:"ROS 2 Control Configuration",children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# Configuration for ROS 2 Control integration with Gazebo\ncontroller_manager:\n  ros__parameters:\n    update_rate: 1000  # Hz\n    use_sim_time: true\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n\n    arm_controller:\n      type: position_controllers/JointGroupPositionController\n\n    leg_controller:\n      type: position_controllers/JointGroupPositionController\n\narm_controller:\n  ros__parameters:\n    joints:\n      - left_shoulder_joint\n      - left_elbow_joint\n      - left_wrist_joint\n      - right_shoulder_joint\n      - right_elbow_joint\n      - right_wrist_joint\n\nleg_controller:\n  ros__parameters:\n    joints:\n      - left_hip_joint\n      - left_knee_joint\n      - left_ankle_joint\n      - right_hip_joint\n      - right_knee_joint\n      - right_ankle_joint\n\n# Gazebo simulation parameters\ngazebo:\n  ros__parameters:\n    # Physics parameters\n    physics:\n      type: ode\n      max_step_size: 0.001\n      real_time_factor: 1.0\n      real_time_update_rate: 1000.0\n      gravity: [0.0, 0.0, -9.8]\n\n    # Sensor parameters\n    sensors:\n      camera:\n        update_rate: 30.0\n        image_width: 640\n        image_height: 480\n        fov: 1.047\n        distortion:\n          k1: -0.1\n          k2: 0.02\n          p1: 0.0\n          p2: 0.0\n\n      imu:\n        update_rate: 100.0\n        noise_density: 0.0001\n        random_walk: 0.0001\n\n    # Joint parameters\n    joints:\n      left_hip_joint:\n        friction: 0.1\n        damping: 1.0\n      right_hip_joint:\n        friction: 0.1\n        damping: 1.0\n      # Add parameters for other joints as needed\n"})})})]}),"\n",(0,t.jsx)(e.h3,{id:"example-2-simulation-integration-node",children:"Example 2: Simulation Integration Node"}),"\n",(0,t.jsxs)(r.A,{children:[(0,t.jsx)(a.A,{value:"integration_node",label:"Simulation Integration Node",children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# Example: Simulation integration node for humanoid robot\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom sensor_msgs.msg import JointState, Imu, LaserScan\nfrom geometry_msgs.msg import Twist, PoseStamped\nfrom std_msgs.msg import Float64MultiArray, Bool, String\nfrom trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint\nfrom control_msgs.action import FollowJointTrajectory\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom builtin_interfaces.msg import Duration\nimport time\nimport threading\nimport numpy as np\nfrom collections import deque\n\n\nclass SimulationIntegrationNode(Node):\n    \"\"\"\n    A node that manages the integration between simulation and control systems.\n    Handles sensor data processing, control command forwarding, and simulation validation.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('simulation_integration')\n\n        # Declare parameters\n        self.declare_parameter('use_sim_time', True)\n        self.declare_parameter('control_frequency', 100)\n        self.declare_parameter('sensor_frequency', 50)\n        self.declare_parameter('validation_frequency', 10)\n        self.declare_parameter('sim_fidelity_threshold', 0.05)\n\n        # Get parameter values\n        self.use_sim_time = self.get_parameter('use_sim_time').value\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.sensor_frequency = self.get_parameter('sensor_frequency').value\n        self.validation_frequency = self.get_parameter('validation_frequency').value\n        self.fidelity_threshold = self.get_parameter('sim_fidelity_threshold').value\n\n        # State tracking\n        self.joint_states = None\n        self.imu_data = None\n        self.laser_scan = None\n        self.control_commands = None\n\n        # History for validation\n        self.joint_history = deque(maxlen=100)\n        self.control_history = deque(maxlen=100)\n\n        # QoS profiles for different data types\n        sensor_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        control_qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.RELIABLE,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        # Subscribers for simulation sensor data\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10,\n            callback_group=rclpy.callback_groups.ReentrantCallbackGroup()\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/imu/data',\n            self.imu_callback,\n            sensor_qos,\n            callback_group=rclpy.callback_groups.ReentrantCallbackGroup()\n        )\n\n        self.laser_sub = self.create_subscription(\n            LaserScan,\n            '/scan',\n            self.laser_callback,\n            sensor_qos,\n            callback_group=rclpy.callback_groups.ReentrantCallbackGroup()\n        )\n\n        # Publishers for control commands\n        self.joint_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            '/joint_group_position_controller/commands',\n            control_qos\n        )\n\n        self.cmd_vel_pub = self.create_publisher(\n            Twist,\n            '/cmd_vel',\n            control_qos\n        )\n\n        # Publishers for validation and monitoring\n        self.sim_validation_pub = self.create_publisher(\n            Float64MultiArray,\n            '/simulation/validation',\n            10\n        )\n\n        self.sim_status_pub = self.create_publisher(\n            String,\n            '/simulation/status',\n            10\n        )\n\n        # Action server for trajectory execution\n        self.trajectory_action_server = ActionServer(\n            self,\n            FollowJointTrajectory,\n            'joint_trajectory_controller/follow_joint_trajectory',\n            execute_callback=self.execute_trajectory_callback,\n            goal_callback=self.trajectory_goal_callback,\n            cancel_callback=self.trajectory_cancel_callback\n        )\n\n        # Timers for different functions\n        control_period = 1.0 / self.control_frequency\n        self.control_timer = self.create_timer(\n            control_period,\n            self.control_loop,\n            callback_group=rclpy.callback_groups.ReentrantCallbackGroup()\n        )\n\n        validation_period = 1.0 / self.validation_frequency\n        self.validation_timer = self.create_timer(\n            validation_period,\n            self.validation_loop,\n            callback_group=rclpy.callback_groups.ReentrantCallbackGroup()\n        )\n\n        # Initialize simulation status\n        self.simulation_running = True\n        self.simulation_fidelity = 1.0  # 1.0 = perfect, 0.0 = no fidelity\n\n        self.get_logger().info(f'Simulation Integration Node initialized with {self.control_frequency}Hz control rate')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Handle joint state updates from simulation.\"\"\"\n        self.joint_states = msg\n\n        # Store in history for validation\n        self.joint_history.append({\n            'timestamp': time.time(),\n            'positions': list(msg.position),\n            'velocities': list(msg.velocity),\n            'efforts': list(msg.effort)\n        })\n\n        # Validate joint limits\n        for i, (name, pos) in enumerate(zip(msg.name, msg.position)):\n            if abs(pos) > 3.14:  # Check for extreme positions\n                self.get_logger().warn(f'Joint {name} has extreme position: {pos}')\n\n    def imu_callback(self, msg):\n        \"\"\"Handle IMU data from simulation.\"\"\"\n        self.imu_data = msg\n\n        # Check for balance (simplified - looking at orientation)\n        pitch = self.get_pitch_from_quaternion(msg.orientation)\n        if abs(pitch) > 0.5:  # More than ~28 degrees\n            self.get_logger().warn(f'Robot tilt angle: {pitch:.3f} - possible balance issue')\n\n    def laser_callback(self, msg):\n        \"\"\"Handle laser scan data from simulation.\"\"\"\n        self.laser_scan = msg\n\n        # Check for obstacles (simplified - looking at front range)\n        if len(msg.ranges) > 0:\n            front_range = msg.ranges[len(msg.ranges) // 2]  # Middle range is front\n            if 0 < front_range < 0.5:  # Obstacle within 50cm\n                self.get_logger().info(f'Obstacle detected at {front_range:.2f}m')\n\n    def get_pitch_from_quaternion(self, orientation):\n        \"\"\"Extract pitch angle from quaternion.\"\"\"\n        import math\n        # Simplified pitch calculation\n        sinr_cosp = 2 * (orientation.w * orientation.y - orientation.z * orientation.x)\n        cosr_cosp = 1 - 2 * (orientation.y * orientation.y + orientation.x * orientation.x)\n        return math.atan2(sinr_cosp, cosr_cosp)\n\n    def control_loop(self):\n        \"\"\"Main control loop that processes and validates simulation data.\"\"\"\n        if not self.simulation_running:\n            return\n\n        # Process sensor data and prepare control commands\n        control_cmd = self.generate_control_commands()\n\n        if control_cmd is not None:\n            # Publish control commands\n            self.joint_cmd_pub.publish(control_cmd)\n\n            # Store command in history for validation\n            self.control_history.append({\n                'timestamp': time.time(),\n                'commands': list(control_cmd.data)\n            })\n\n    def generate_control_commands(self):\n        \"\"\"Generate control commands based on current state.\"\"\"\n        # In a real implementation, this would contain actual control logic\n        # For this example, we'll just return a simple command pattern\n\n        if self.joint_states is None:\n            return None\n\n        # Example: Simple joint position control\n        # This would typically come from a higher-level controller\n        cmd_msg = Float64MultiArray()\n\n        # For demonstration, we'll send a simple oscillating pattern\n        # In reality, this would come from a motion planner or controller\n        commands = []\n        current_time = time.time()\n\n        for i, joint_name in enumerate(self.joint_states.name):\n            # Create a simple oscillating pattern for demonstration\n            if 'hip' in joint_name.lower():\n                command = 0.1 * np.sin(current_time * 0.5)\n            elif 'knee' in joint_name.lower():\n                command = 0.05 * np.sin(current_time * 0.7)\n            elif 'ankle' in joint_name.lower():\n                command = 0.08 * np.sin(current_time * 0.3)\n            else:\n                command = 0.0  # Default position for other joints\n\n            commands.append(command)\n\n        cmd_msg.data = commands\n        return cmd_msg\n\n    def validation_loop(self):\n        \"\"\"Validate simulation fidelity and performance.\"\"\"\n        if not self.joint_states or not self.control_history:\n            return\n\n        # Calculate simulation fidelity metrics\n        fidelity_metrics = self.calculate_fidelity_metrics()\n\n        # Publish validation results\n        validation_msg = Float64MultiArray()\n        validation_msg.data = [\n            fidelity_metrics.get('fidelity_score', 0.0),\n            fidelity_metrics.get('response_delay', 0.0),\n            fidelity_metrics.get('control_accuracy', 0.0),\n            fidelity_metrics.get('sensor_consistency', 0.0)\n        ]\n\n        self.sim_validation_pub.publish(validation_msg)\n\n        # Update simulation status\n        status_msg = String()\n        if fidelity_metrics.get('fidelity_score', 0.0) < self.fidelity_threshold:\n            status_msg.data = f'LOW_FIDELITY ({fidelity_metrics.get(\"fidelity_score\", 0.0):.3f})'\n            self.get_logger().warn(f'Simulation fidelity below threshold: {fidelity_metrics.get(\"fidelity_score\", 0.0):.3f}')\n        else:\n            status_msg.data = f'VALID ({fidelity_metrics.get(\"fidelity_score\", 0.0):.3f})'\n\n        self.sim_status_pub.publish(status_msg)\n\n    def calculate_fidelity_metrics(self):\n        \"\"\"Calculate various fidelity metrics for simulation validation.\"\"\"\n        metrics = {}\n\n        # Calculate response delay (simplified)\n        if self.joint_history and self.control_history:\n            # Estimate delay between command and response\n            recent_joint = self.joint_history[-1] if self.joint_history else None\n            recent_control = self.control_history[-1] if self.control_history else None\n\n            if recent_joint and recent_control:\n                delay = abs(recent_joint['timestamp'] - recent_control['timestamp'])\n                metrics['response_delay'] = delay\n\n        # Calculate control accuracy (simplified)\n        if self.joint_states and len(self.control_history) > 0:\n            latest_command = self.control_history[-1]['commands']\n            current_positions = self.joint_states.position\n\n            # Calculate average difference between command and actual position\n            if len(latest_command) == len(current_positions):\n                diffs = [abs(cmd - pos) for cmd, pos in zip(latest_command, current_positions)]\n                avg_diff = sum(diffs) / len(diffs) if diffs else 0.0\n                metrics['control_accuracy'] = 1.0 / (1.0 + avg_diff)  # Convert to 0-1 scale\n\n        # Calculate sensor consistency (simplified)\n        if self.imu_data and self.joint_states:\n            # Check if IMU data is consistent with joint state expectations\n            # This is a simplified check - in reality, you'd have more sophisticated validation\n            metrics['sensor_consistency'] = 0.9  # Placeholder value\n\n        # Overall fidelity score (simplified)\n        accuracy = metrics.get('control_accuracy', 0.5)\n        consistency = metrics.get('sensor_consistency', 0.5)\n        metrics['fidelity_score'] = (accuracy + consistency) / 2.0\n\n        return metrics\n\n    def execute_trajectory_callback(self, goal_handle):\n        \"\"\"Execute joint trajectory in simulation.\"\"\"\n        self.get_logger().info('Executing joint trajectory in simulation')\n\n        # In a real implementation, this would send the trajectory to the simulation\n        # For this example, we'll just simulate execution\n\n        feedback_msg = FollowJointTrajectory.Feedback()\n        result = FollowJointTrajectory.Result()\n\n        for i, point in enumerate(goal_handle.request.trajectory.points):\n            # Check if the goal was canceled\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                result.error_code = FollowJointTrajectory.Result.PATH_TOLERANCE_VIOLATED\n                return result\n\n            # Simulate trajectory execution\n            # In reality, this would involve sending commands to the simulated joints\n            time.sleep(0.1)  # Simulate time for each point\n\n            # Update feedback\n            feedback_msg.joint_names = goal_handle.request.trajectory.joint_names\n            feedback_msg.actual.positions = list(point.positions)\n            feedback_msg.desired.positions = list(point.positions)\n\n            progress = float(i + 1) / len(goal_handle.request.trajectory.points)\n            feedback_msg.progress = progress\n\n            goal_handle.publish_feedback(feedback_msg)\n\n        # Complete successfully\n        goal_handle.succeed()\n        result.error_code = FollowJointTrajectory.Result.SUCCESSFUL\n        self.get_logger().info('Joint trajectory completed successfully')\n        return result\n\n    def trajectory_goal_callback(self, goal_request):\n        \"\"\"Accept or reject trajectory goals.\"\"\"\n        # Check if trajectory is valid and can be executed\n        if len(goal_request.trajectory.points) == 0:\n            self.get_logger().warn('Received trajectory with no points')\n            return GoalResponse.REJECT\n\n        # Check if joint names match expected joints\n        expected_joints = ['left_hip', 'left_knee', 'left_ankle', 'right_hip', 'right_knee', 'right_ankle']\n        requested_joints = goal_request.trajectory.joint_names\n\n        # This is a simplified check - in reality, you'd validate more thoroughly\n        if all(joint in expected_joints for joint in requested_joints):\n            self.get_logger().info(f'Accepting trajectory goal for joints: {requested_joints}')\n            return GoalResponse.ACCEPT\n        else:\n            self.get_logger().warn(f'Rejecting trajectory - joints {requested_joints} not supported')\n            return GoalResponse.REJECT\n\n    def trajectory_cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject trajectory cancellation.\"\"\"\n        self.get_logger().info('Received trajectory cancellation request')\n        return CancelResponse.ACCEPT\n\n    def get_simulation_status(self):\n        \"\"\"Get current simulation status and metrics.\"\"\"\n        status = {\n            'running': self.simulation_running,\n            'fidelity': self.simulation_fidelity,\n            'joint_count': len(self.joint_states.name) if self.joint_states else 0,\n            'control_frequency': self.control_frequency,\n            'validation_frequency': self.validation_frequency\n        }\n        return status\n\n\ndef main(args=None):\n    \"\"\"Main function to run the simulation integration node.\"\"\"\n    rclpy.init(args=args)\n\n    node = SimulationIntegrationNode()\n\n    # Use a multi-threaded executor to handle multiple callbacks\n    executor = rclpy.executors.MultiThreadedExecutor()\n    executor.add_node(node)\n\n    try:\n        node.get_logger().info('Simulation Integration Node started')\n        executor.spin()\n    except KeyboardInterrupt:\n        node.get_logger().info('Interrupted by user')\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})})}),(0,t.jsx)(a.A,{value:"unity_ros_bridge",label:"Unity-ROS Bridge Node",children:(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n# Example: Unity-ROS bridge node for visualization integration\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom sensor_msgs.msg import JointState, Imu, Image\nfrom geometry_msgs.msg import Twist, Pose, Point\nfrom std_msgs.msg import Float64MultiArray, String, Bool\nfrom visualization_msgs.msg import Marker, MarkerArray\nfrom tf2_msgs.msg import TFMessage\nimport socket\nimport json\nimport threading\nimport time\nfrom collections import defaultdict\n\n\nclass UnityROSBridge(Node):\n    \"\"\"\n    A node that bridges between ROS 2 and Unity for visualization and interaction.\n    Handles message conversion between ROS and Unity formats.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('unity_ros_bridge')\n\n        # Declare parameters\n        self.declare_parameter('unity_ip', '127.0.0.1')\n        self.declare_parameter('unity_port', 5005)\n        self.declare_parameter('ros_frequency', 30)\n        self.declare_parameter('unity_frequency', 60)\n\n        # Get parameter values\n        self.unity_ip = self.get_parameter('unity_ip').value\n        self.unity_port = self.get_parameter('unity_port').value\n        self.ros_frequency = self.get_parameter('ros_frequency').value\n        self.unity_frequency = self.get_parameter('unity_frequency').value\n\n        # Setup ROS communication\n        qos = QoSProfile(\n            depth=10,\n            reliability=ReliabilityPolicy.BEST_EFFORT,\n            durability=DurabilityPolicy.VOLATILE\n        )\n\n        # ROS subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            '/imu/data',\n            self.imu_callback,\n            qos\n        )\n\n        self.cmd_vel_sub = self.create_subscription(\n            Twist,\n            '/cmd_vel',\n            self.cmd_vel_callback,\n            10\n        )\n\n        # ROS publishers for Unity commands\n        self.unity_cmd_pub = self.create_publisher(\n            String,\n            '/unity_commands',\n            10\n        )\n\n        # Visualization publishers\n        self.marker_pub = self.create_publisher(\n            Marker,\n            '/unity_visualization',\n            10\n        )\n\n        self.tf_pub = self.create_publisher(\n            TFMessage,\n            '/tf',\n            10\n        )\n\n        # Initialize Unity connection\n        self.unity_socket = None\n        self.connect_to_unity()\n\n        # Data storage\n        self.robot_state = {\n            'joint_positions': {},\n            'imu_data': None,\n            'robot_pose': {'x': 0, 'y': 0, 'z': 0, 'qx': 0, 'qy': 0, 'qz': 0, 'qw': 1}\n        }\n\n        # Setup timers\n        ros_period = 1.0 / self.ros_frequency\n        self.ros_timer = self.create_timer(ros_period, self.ros_update_loop)\n\n        unity_period = 1.0 / self.unity_frequency\n        self.unity_timer = self.create_timer(unity_period, self.unity_update_loop)\n\n        # Threading for Unity communication\n        self.unity_thread = threading.Thread(target=self.listen_to_unity, daemon=True)\n        self.unity_thread.start()\n\n        self.get_logger().info(f'Unity-ROS Bridge initialized - connecting to {self.unity_ip}:{self.unity_port}')\n\n    def connect_to_unity(self):\n        \"\"\"Establish connection to Unity application.\"\"\"\n        try:\n            self.unity_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n            self.unity_socket.settimeout(1.0)\n            self.get_logger().info(f'Connected to Unity at {self.unity_ip}:{self.unity_port}')\n        except Exception as e:\n            self.get_logger().error(f'Failed to connect to Unity: {e}')\n\n    def listen_to_unity(self):\n        \"\"\"Listen for messages from Unity.\"\"\"\n        if not self.unity_socket:\n            return\n\n        while rclpy.ok():\n            try:\n                data, addr = self.unity_socket.recvfrom(4096)\n                message = data.decode('utf-8')\n\n                # Parse Unity message\n                try:\n                    unity_msg = json.loads(message)\n                    self.process_unity_message(unity_msg)\n                except json.JSONDecodeError:\n                    self.get_logger().warn(f'Invalid JSON from Unity: {message}')\n\n            except socket.timeout:\n                continue  # No message received, continue loop\n            except Exception as e:\n                self.get_logger().error(f'Error receiving from Unity: {e}')\n                time.sleep(0.1)  # Brief pause before retrying\n\n    def process_unity_message(self, msg):\n        \"\"\"Process messages received from Unity.\"\"\"\n        msg_type = msg.get('type', '')\n\n        if msg_type == 'user_command':\n            # Process user commands from Unity UI\n            command = msg.get('command', '')\n            self.handle_user_command(command, msg)\n        elif msg_type == 'robot_interaction':\n            # Process robot interaction from Unity scene\n            interaction = msg.get('interaction', {})\n            self.handle_robot_interaction(interaction)\n        elif msg_type == 'visualization_request':\n            # Process visualization requests\n            viz_request = msg.get('request', {})\n            self.handle_visualization_request(viz_request)\n\n    def joint_state_callback(self, msg):\n        \"\"\"Handle joint state updates from ROS.\"\"\"\n        for i, (name, position) in enumerate(zip(msg.name, msg.position)):\n            self.robot_state['joint_positions'][name] = position\n\n    def imu_callback(self, msg):\n        \"\"\"Handle IMU data from ROS.\"\"\"\n        self.robot_state['imu_data'] = {\n            'orientation': {\n                'x': msg.orientation.x,\n                'y': msg.orientation.y,\n                'z': msg.orientation.z,\n                'w': msg.orientation.w\n            },\n            'angular_velocity': {\n                'x': msg.angular_velocity.x,\n                'y': msg.angular_velocity.y,\n                'z': msg.angular_velocity.z\n            },\n            'linear_acceleration': {\n                'x': msg.linear_acceleration.x,\n                'y': msg.linear_acceleration.y,\n                'z': msg.linear_acceleration.z\n            }\n        }\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Handle velocity commands from ROS.\"\"\"\n        # Update robot pose based on velocity (simplified integration)\n        # In a real system, this would integrate with actual robot pose\n        pass\n\n    def handle_user_command(self, command, details):\n        \"\"\"Handle commands from Unity UI.\"\"\"\n        if command == 'reset_simulation':\n            self.get_logger().info('Reset command received from Unity')\n            # Publish reset command to appropriate ROS topic\n            reset_msg = String()\n            reset_msg.data = 'reset'\n            self.unity_cmd_pub.publish(reset_msg)\n        elif command == 'start_recording':\n            self.get_logger().info('Start recording command from Unity')\n            # Handle recording start\n        elif command == 'stop_recording':\n            self.get_logger().info('Stop recording command from Unity')\n            # Handle recording stop\n\n    def handle_robot_interaction(self, interaction):\n        \"\"\"Handle robot interactions from Unity scene.\"\"\"\n        interaction_type = interaction.get('type', '')\n        target = interaction.get('target', '')\n\n        if interaction_type == 'click':\n            self.get_logger().info(f'Robot interaction: {target}')\n            # Handle click on robot part\n        elif interaction_type == 'drag':\n            # Handle drag interaction\n            pass\n\n    def handle_visualization_request(self, request):\n        \"\"\"Handle visualization requests from Unity.\"\"\"\n        request_type = request.get('request_type', '')\n\n        if request_type == 'sensor_overlay':\n            # Send sensor data for visualization overlay\n            self.send_sensor_visualization()\n        elif request_type == 'trajectory_display':\n            # Send trajectory data for visualization\n            self.send_trajectory_visualization()\n\n    def ros_update_loop(self):\n        \"\"\"Update ROS data structures.\"\"\"\n        # This method runs at ROS frequency\n        # Perform any ROS-side updates needed\n        pass\n\n    def unity_update_loop(self):\n        \"\"\"Send data to Unity.\"\"\"\n        if not self.unity_socket:\n            return\n\n        # Prepare robot state data for Unity\n        unity_data = {\n            'type': 'robot_state',\n            'timestamp': time.time(),\n            'joint_positions': self.robot_state['joint_positions'],\n            'imu_data': self.robot_state['imu_data'],\n            'robot_pose': self.robot_state['robot_pose']\n        }\n\n        try:\n            json_data = json.dumps(unity_data)\n            self.unity_socket.sendto(json_data.encode('utf-8'), (self.unity_ip, self.unity_port))\n        except Exception as e:\n            self.get_logger().error(f'Error sending to Unity: {e}')\n\n    def send_sensor_visualization(self):\n        \"\"\"Send sensor data for visualization in Unity.\"\"\"\n        if not self.unity_socket:\n            return\n\n        # Prepare sensor visualization data\n        viz_data = {\n            'type': 'sensor_visualization',\n            'timestamp': time.time(),\n            'sensor_data': {\n                'laser_scan': self.get_recent_laser_scan(),\n                'camera_feed': self.get_recent_camera_image(),\n                'imu_orientation': self.robot_state['imu_data']['orientation'] if self.robot_state['imu_data'] else None\n            }\n        }\n\n        try:\n            json_data = json.dumps(viz_data)\n            self.unity_socket.sendto(json_data.encode('utf-8'), (self.unity_ip, self.unity_port))\n        except Exception as e:\n            self.get_logger().error(f'Error sending sensor viz to Unity: {e}')\n\n    def get_recent_laser_scan(self):\n        \"\"\"Get recent laser scan data (placeholder).\"\"\"\n        # In a real implementation, you'd get this from a laser scan subscriber\n        return {'ranges': [1.0] * 360, 'intensities': [100] * 360}\n\n    def get_recent_camera_image(self):\n        \"\"\"Get recent camera image data (placeholder).\"\"\"\n        # In a real implementation, you'd get this from a camera subscriber\n        return {'width': 640, 'height': 480, 'encoding': 'rgb8'}\n\n    def send_trajectory_visualization(self):\n        \"\"\"Send trajectory data for visualization.\"\"\"\n        if not self.unity_socket:\n            return\n\n        # Prepare trajectory visualization data\n        traj_data = {\n            'type': 'trajectory_visualization',\n            'timestamp': time.time(),\n            'trajectory': [\n                {'x': 0, 'y': 0, 'z': 0},\n                {'x': 1, 'y': 0, 'z': 0},\n                {'x': 2, 'y': 1, 'z': 0},\n                {'x': 3, 'y': 1, 'z': 0}\n            ]\n        }\n\n        try:\n            json_data = json.dumps(traj_data)\n            self.unity_socket.sendto(json_data.encode('utf-8'), (self.unity_ip, self.unity_port))\n        except Exception as e:\n            self.get_logger().error(f'Error sending trajectory viz to Unity: {e}')\n\n\ndef main(args=None):\n    \"\"\"Main function to run the Unity-ROS bridge.\"\"\"\n    rclpy.init(args=args)\n\n    bridge = UnityROSBridge()\n\n    try:\n        bridge.get_logger().info('Unity-ROS Bridge started')\n        rclpy.spin(bridge)\n    except KeyboardInterrupt:\n        bridge.get_logger().info('Unity-ROS Bridge interrupted')\n    finally:\n        bridge.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})})})]}),"\n",(0,t.jsx)(e.h2,{id:"exercises-and-checkpoints",children:"Exercises and Checkpoints"}),"\n",(0,t.jsx)(e.h3,{id:"exercise-1-simulation-integration-architecture",children:"Exercise 1: Simulation Integration Architecture"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Scenario:"})," You're designing the integration architecture for a humanoid robot simulation system that needs to support:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Real-time physics simulation with Gazebo"}),"\n",(0,t.jsx)(e.li,{children:"High-quality visualization with Unity"}),"\n",(0,t.jsx)(e.li,{children:"ROS 2 control and planning systems"}),"\n",(0,t.jsx)(e.li,{children:"Multi-robot coordination scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Human-robot interaction interfaces"}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Task:"})," Design an integration architecture that addresses all these requirements, including:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Data flow between components"}),"\n",(0,t.jsx)(e.li,{children:"Communication protocols and QoS settings"}),"\n",(0,t.jsx)(e.li,{children:"Performance optimization strategies"}),"\n",(0,t.jsx)(e.li,{children:"Error handling and recovery mechanisms"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Success Criteria:"})}),"\n",(0,t.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Clear component architecture with defined interfaces"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Appropriate communication patterns for each requirement"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Performance considerations addressed"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Robust error handling implemented"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-2-gazebo-ros-integration-implementation",children:"Exercise 2: Gazebo-ROS Integration Implementation"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Objective:"})," Implement a complete Gazebo-ROS integration for a humanoid robot with proper sensor simulation and control."]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Task:"})," Create the necessary configuration files and nodes to:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Spawn a humanoid robot model in Gazebo"}),"\n",(0,t.jsx)(e.li,{children:"Publish realistic sensor data (IMU, cameras, LiDAR)"}),"\n",(0,t.jsx)(e.li,{children:"Subscribe to joint control commands"}),"\n",(0,t.jsx)(e.li,{children:"Implement proper coordinate frame transformations"}),"\n",(0,t.jsx)(e.li,{children:"Validate simulation fidelity"}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.strong,{children:"Success Criteria:"})}),"\n",(0,t.jsxs)(e.ul,{className:"contains-task-list",children:["\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Robot successfully spawns in Gazebo"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Sensor data published with realistic characteristics"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Joint control commands properly received and executed"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","TF frames correctly published"]}),"\n",(0,t.jsxs)(e.li,{className:"task-list-item",children:[(0,t.jsx)(e.input,{type:"checkbox",disabled:!0})," ","Simulation validated against expected behavior"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Question:"})," What are the key components of Gazebo-ROS integration?\n",(0,t.jsx)(e.strong,{children:"Answer:"})," Key components include: sensor plugins that publish ROS messages, actuator plugins that subscribe to ROS commands, model plugins for custom behaviors, and the Gazebo-ROS bridge that handles communication."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Question:"})," How does Unity-ROS integration differ from Gazebo-ROS integration?\n",(0,t.jsx)(e.strong,{children:"Answer:"})," Unity-ROS integration typically uses network-based communication (TCP/UDP) through libraries like ROS#, while Gazebo-ROS integration is more direct through plugins. Unity focuses on visualization and interaction, while Gazebo focuses on physics simulation."]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Question:"})," What are important considerations for simulation fidelity validation?\n",(0,t.jsx)(e.strong,{children:"Answer:"})," Important considerations include: comparing sensor data characteristics, validating control response times, checking physical parameter accuracy, ensuring proper timing synchronization, and verifying that behaviors transfer from sim to real."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary-and-key-takeaways",children:"Summary and Key Takeaways"}),"\n",(0,t.jsx)(e.h3,{id:"key-concepts-recap",children:"Key Concepts Recap"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Integration Architecture"}),": Standardized patterns for connecting simulation and control systems"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gazebo-ROS Bridge"}),": Direct plugin-based communication between simulation and ROS"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Unity-ROS Bridge"}),": Network-based communication for visualization and interaction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fidelity Validation"}),": Ensuring simulation matches real-world behavior"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Performance Optimization"}),": Balancing accuracy with computational efficiency"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Development Acceleration"}),": Rapid testing of robot behaviors in simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safety Validation"}),": Testing dangerous scenarios without physical risk"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Human-Robot Interaction"}),": Intuitive interfaces for robot operation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Multi-Robot Systems"}),": Coordinated simulation of multiple robots"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Module Progression:"})," Complete Module 2 with exercises and integration implementation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Further Reading:"})," Explore advanced simulation techniques and domain randomization"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Practice Opportunities:"})," Implement complete simulation-integration for your robot"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"common-mistakes-and-troubleshooting",children:"Common Mistakes and Troubleshooting"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Mistake 1:"})," Poor coordinate frame management \u2192 ",(0,t.jsx)(e.strong,{children:"Solution:"})," Implement proper TF tree and transformations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Mistake 2:"})," Inadequate sensor simulation \u2192 ",(0,t.jsx)(e.strong,{children:"Solution:"})," Include realistic noise and limitations"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Mistake 3:"})," Unstable communication patterns \u2192 ",(0,t.jsx)(e.strong,{children:"Solution:"})," Use appropriate QoS settings and error handling"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"references-and-resources",children:"References and Resources"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://gazebosim.org/docs/harmonic/ros_integration",children:"Gazebo-ROS Bridge Documentation"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://github.com/Unity-Technologies/Unity-Robotics-Hub",children:"Unity Robotics Hub"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://control.ros.org/",children:"ROS 2 Control Integration"})}),"\n",(0,t.jsx)(e.li,{children:(0,t.jsx)(e.a,{href:"https://discourse.ros.org/c/simulation/",children:"Simulation Best Practices"})}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(g,{...n})}):g(n)}}}]);