"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[5109],{354(e,n,t){t.r(n),t.d(n,{assets:()=>m,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>d,toc:()=>h});var s=t(4848),i=t(8453),o=t(4252),r=t(1470),a=t(9365);const l={title:"System Integration",description:"Learn how to integrate all ROS 2 concepts into a complete humanoid robot system",tags:["ros2","system integration","architecture","complete system","humanoid"],sidebar_label:"System Integration",sidebar_position:6,keywords:["ros2","system integration","architecture","complete robot system"],toc_min_heading_level:2,toc_max_heading_level:4},c="System Integration",d={id:"module-1-ros2/system-integration",title:"System Integration",description:"Learn how to integrate all ROS 2 concepts into a complete humanoid robot system",source:"@site/docs/module-1-ros2/system-integration.mdx",sourceDirName:"module-1-ros2",slug:"/module-1-ros2/system-integration",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/system-integration",draft:!1,unlisted:!1,editUrl:"https://github.com/Asim1112/Physical-AI-Humanoid-Robotics-Book/edit/main/frontend/docs/module-1-ros2/system-integration.mdx",tags:[{label:"ros2",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/ros-2"},{label:"system integration",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/system-integration"},{label:"architecture",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/architecture"},{label:"complete system",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/complete-system"},{label:"humanoid",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/humanoid"}],version:"current",sidebarPosition:6,frontMatter:{title:"System Integration",description:"Learn how to integrate all ROS 2 concepts into a complete humanoid robot system",tags:["ros2","system integration","architecture","complete system","humanoid"],sidebar_label:"System Integration",sidebar_position:6,keywords:["ros2","system integration","architecture","complete robot system"],toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"tutorialSidebar",previous:{title:"URDF Modeling",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/urdf-modeling"},next:{title:"Exercises and Checkpoints",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/exercises-checkpoints"}},m={},h=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Deep Explanation",id:"deep-explanation",level:2},{value:"System Architecture Patterns",id:"system-architecture-patterns",level:3},{value:"Integration Challenges",id:"integration-challenges",level:3},{value:"System Design Considerations",id:"system-design-considerations",level:3},{value:"Launch Files and System Management",id:"launch-files-and-system-management",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Complete Humanoid Robot System",id:"example-1-complete-humanoid-robot-system",level:3},{value:"Example 2: Parameter Management and System Configuration",id:"example-2-parameter-management-and-system-configuration",level:3},{value:"Exercises and Checkpoints",id:"exercises-and-checkpoints",level:2},{value:"Exercise 1: System Architecture Design",id:"exercise-1-system-architecture-design",level:3},{value:"Exercise 2: Practical Implementation",id:"exercise-2-practical-implementation",level:3},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:3},{value:"Summary and Key Takeaways",id:"summary-and-key-takeaways",level:2},{value:"Key Concepts Recap",id:"key-concepts-recap",level:3},{value:"Practical Applications",id:"practical-applications",level:3},{value:"Next Steps",id:"next-steps",level:3},{value:"Common Mistakes and Troubleshooting",id:"common-mistakes-and-troubleshooting",level:3},{value:"References and Resources",id:"references-and-resources",level:3}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"system-integration",children:"System Integration"}),"\n","\n","\n",(0,s.jsx)(o.A,{toc:h}),"\n",(0,s.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,s.jsx)(n.p,{children:"In this final chapter of Module 1, we'll bring together all the concepts learned in previous chapters to create a complete humanoid robot system. System integration is the process of combining individual components into a cohesive, functional whole that meets the overall robot objectives."}),"\n",(0,s.jsx)(n.p,{children:"This chapter demonstrates how nodes, topics, services, actions, and URDF models work together in a real humanoid robot application. We'll explore architectural patterns, system design considerations, and best practices for building robust robotic systems that can handle the complexity of humanoid robotics."}),"\n",(0,s.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understand architectural patterns for complete robotic systems"}),"\n",(0,s.jsx)(n.li,{children:"Design and implement a complete humanoid robot control system"}),"\n",(0,s.jsx)(n.li,{children:"Integrate communication patterns (topics, services, actions) effectively"}),"\n",(0,s.jsx)(n.li,{children:"Combine URDF models with control systems"}),"\n",(0,s.jsx)(n.li,{children:"Apply system-level debugging and testing techniques"}),"\n",(0,s.jsx)(n.li,{children:"Plan for scalability and maintainability in robotic systems"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Complete understanding of all previous Module 1 chapters"}),"\n",(0,s.jsx)(n.li,{children:"Experience with ROS 2 nodes, topics, services, and actions"}),"\n",(0,s.jsx)(n.li,{children:"Knowledge of URDF modeling"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"deep-explanation",children:"Deep Explanation"}),"\n",(0,s.jsx)(n.h3,{id:"system-architecture-patterns",children:"System Architecture Patterns"}),"\n",(0,s.jsx)(n.p,{children:"When designing complete robotic systems, several architectural patterns emerge that help manage complexity:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Layered Architecture"}),": Organizes functionality into layers (hardware abstraction, control, planning, behavior)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component-Based Architecture"}),": Treats robot functionality as independent, reusable components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service-Oriented Architecture"}),": Uses services to provide specific capabilities to other system parts"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event-Driven Architecture"}),": Uses topics and actions to respond to system events"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For humanoid robots, a hybrid approach often works best, combining these patterns based on specific needs."}),"\n",(0,s.jsx)(n.h3,{id:"integration-challenges",children:"Integration Challenges"}),"\n",(0,s.jsx)(n.p,{children:"Humanoid robot systems face unique integration challenges:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Complex Kinematics"}),": Multiple interconnected limbs requiring coordinated control"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Real-time Requirements"}),": Balance and locomotion need high-frequency control loops"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor Fusion"}),": Combining data from many sensors (IMU, cameras, joint encoders, etc.)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety Critical Operations"}),": Systems must fail safely to prevent damage"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Computational Demands"}),": Processing power needed for perception, planning, and control"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"system-design-considerations",children:"System Design Considerations"}),"\n",(0,s.jsx)(n.p,{children:"When integrating a complete humanoid system, consider:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modularity"}),": Keep components independent for easier testing and maintenance"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),": Design systems that can accommodate additional sensors or capabilities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Fault Tolerance"}),": Implement graceful degradation when components fail"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Performance"}),": Optimize communication patterns for real-time requirements"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Debugging"}),": Include tools and interfaces for system monitoring and debugging"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"launch-files-and-system-management",children:"Launch Files and System Management"}),"\n",(0,s.jsx)(n.p,{children:"ROS 2 launch files are crucial for system integration, allowing you to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Start multiple nodes simultaneously"}),"\n",(0,s.jsx)(n.li,{children:"Configure parameters for the entire system"}),"\n",(0,s.jsx)(n.li,{children:"Manage dependencies between nodes"}),"\n",(0,s.jsx)(n.li,{children:"Handle system startup and shutdown procedures"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Launch files enable reproducible system configurations and simplify deployment."}),"\n",(0,s.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,s.jsx)(n.h3,{id:"example-1-complete-humanoid-robot-system",children:"Example 1: Complete Humanoid Robot System"}),"\n",(0,s.jsxs)(r.A,{children:[(0,s.jsx)(a.A,{value:"launch",label:"Launch File",default:!0,children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<launch>\n  \x3c!-- Arguments for configuration --\x3e\n  <arg name="robot_model" default="simple_humanoid"/>\n  <arg name="use_sim_time" default="false"/>\n\n  \x3c!-- Robot state publisher to broadcast transforms --\x3e\n  <node pkg="robot_state_publisher" exec="robot_state_publisher" name="robot_state_publisher">\n    <param name="robot_description" value="$(find-pkg-share my_robot_description)/urdf/$(var robot_model).urdf"/>\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n  \x3c!-- Joint state publisher for GUI control during development --\x3e\n  <node pkg="joint_state_publisher_gui" exec="joint_state_publisher_gui" name="joint_state_publisher_gui">\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n  \x3c!-- IMU sensor driver --\x3e\n  <node pkg="my_robot_drivers" exec="imu_driver" name="imu_driver">\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n    <param name="frame_id" value="imu_link"/>\n  </node>\n\n  \x3c!-- Joint controllers --\x3e\n  <node pkg="controller_manager" exec="ros2_control_node" name="ros2_control_node">\n    <param name="robot_description" value="$(find-pkg-share my_robot_description)/urdf/$(var robot_model).urdf"/>\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n  \x3c!-- Balance controller --\x3e\n  <node pkg="my_robot_controllers" exec="balance_controller" name="balance_controller">\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n    <param name="control_frequency" value="500"/>\n  </node>\n\n  \x3c!-- High-level behavior manager --\x3e\n  <node pkg="my_robot_behaviors" exec="behavior_manager" name="behavior_manager">\n    <param name="use_sim_time" value="$(var use_sim_time)"/>\n  </node>\n\n</launch>\n'})})}),(0,s.jsx)(a.A,{value:"behavior_manager",label:"Behavior Manager Node",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Example: Behavior manager that coordinates high-level robot behaviors\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionClient\nfrom rclpy.callback_groups import MutuallyExclusiveCallbackGroup\nfrom std_msgs.msg import String, Bool\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nfrom my_robot_msgs.action import WalkToPose, ManipulateObject\nfrom my_robot_msgs.srv import SetRobotMode, QueryRobotState\nimport time\nimport threading\n\n\nclass BehaviorManager(Node):\n    """\n    High-level behavior manager that coordinates different robot capabilities.\n    Demonstrates system integration by combining multiple ROS 2 patterns.\n    """\n\n    def __init__(self):\n        super().__init__(\'behavior_manager\')\n\n        # State management\n        self.current_behavior = \'idle\'\n        self.robot_mode = \'normal\'  # normal, safe_mode, calibration\n        self.joint_states = None\n        self.imu_data = None\n\n        # Create callback groups for different functionality\n        sensor_group = MutuallyExclusiveCallbackGroup()\n        control_group = MutuallyExclusiveCallbackGroup()\n\n        # Subscribers for sensor data\n        self.joint_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10,\n            callback_group=sensor_group\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            \'/imu/data\',\n            self.imu_callback,\n            10,\n            callback_group=sensor_group\n        )\n\n        # Publishers for commands\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\n\n        # Service servers for mode control\n        self.set_mode_srv = self.create_service(\n            SetRobotMode,\n            \'set_robot_mode\',\n            self.set_robot_mode_callback\n        )\n\n        self.query_state_srv = self.create_service(\n            QueryRobotState,\n            \'query_robot_state\',\n            self.query_robot_state_callback\n        )\n\n        # Action clients for complex behaviors\n        self.walk_action_client = ActionClient(self, WalkToPose, \'walk_to_pose\')\n        self.manipulate_action_client = ActionClient(self, ManipulateObject, \'manipulate_object\')\n\n        # Timer for behavior updates\n        self.behavior_timer = self.create_timer(0.1, self.behavior_update_callback)\n\n        self.get_logger().info(\'Behavior Manager initialized\')\n\n    def joint_state_callback(self, msg):\n        """Handle joint state updates."""\n        self.joint_states = msg\n        self.check_safety_conditions()\n\n    def imu_callback(self, msg):\n        """Handle IMU data updates."""\n        self.imu_data = msg\n        self.check_balance_conditions()\n\n    def set_robot_mode_callback(self, request, response):\n        """Handle robot mode changes."""\n        old_mode = self.robot_mode\n        self.robot_mode = request.mode\n\n        if self.robot_mode == \'safe_mode\':\n            # Stop all movement in safe mode\n            self.emergency_stop()\n\n        response.success = True\n        response.message = f\'Mode changed from {old_mode} to {self.robot_mode}\'\n\n        self.get_logger().info(f\'Robot mode changed: {response.message}\')\n        return response\n\n    def query_robot_state_callback(self, request, response):\n        """Handle state query requests."""\n        response.current_behavior = self.current_behavior\n        response.robot_mode = self.robot_mode\n        response.joint_count = len(self.joint_states.name) if self.joint_states else 0\n\n        # Check if robot is balanced\n        if self.imu_data:\n            # Simple balance check based on IMU pitch\n            pitch = self.get_pitch_from_quaternion(self.imu_data.orientation)\n            response.is_balanced = abs(pitch) < 0.3  # Within 17 degrees\n        else:\n            response.is_balanced = False\n\n        return response\n\n    def behavior_update_callback(self):\n        """Main behavior update loop."""\n        if self.robot_mode == \'safe_mode\':\n            return  # Don\'t execute behaviors in safe mode\n\n        # Example behavior logic\n        if self.current_behavior == \'idle\':\n            # Check if we should transition to another behavior\n            if self.should_start_walking():\n                self.start_walking_behavior()\n        elif self.current_behavior == \'walking\':\n            # Monitor walking progress\n            if self.is_walking_complete():\n                self.current_behavior = \'idle\'\n\n    def check_safety_conditions(self):\n        """Check for safety-related conditions."""\n        if not self.joint_states:\n            return\n\n        # Check for extreme joint positions\n        for pos in self.joint_states.position:\n            if abs(pos) > 3.0:  # Extreme position check\n                self.get_logger().warn(\'Extreme joint position detected - entering safe mode\')\n                self.emergency_stop()\n                return\n\n    def check_balance_conditions(self):\n        """Check for balance-related conditions."""\n        if not self.imu_data:\n            return\n\n        # Check if robot is tilting too much\n        pitch = self.get_pitch_from_quaternion(self.imu_data.orientation)\n        if abs(pitch) > 0.5:  # More than 28 degrees\n            self.get_logger().warn(\'Robot is tilting excessively - entering safe mode\')\n            self.emergency_stop()\n\n    def get_pitch_from_quaternion(self, orientation):\n        """Extract pitch angle from quaternion."""\n        import math\n        # Convert quaternion to Euler angles (simplified pitch calculation)\n        sinr_cosp = 2 * (orientation.w * orientation.y - orientation.z * orientation.x)\n        cosr_cosp = 1 - 2 * (orientation.y * orientation.y + orientation.x * orientation.x)\n        return math.atan2(sinr_cosp, cosr_cosp)\n\n    def should_start_walking(self):\n        """Determine if walking behavior should start."""\n        # This could be based on various conditions like commands received,\n        # sensor data, or timed events\n        return False  # Placeholder logic\n\n    def start_walking_behavior(self):\n        """Initiate walking behavior."""\n        self.current_behavior = \'walking\'\n        self.get_logger().info(\'Starting walking behavior\')\n\n    def is_walking_complete(self):\n        """Check if walking behavior is complete."""\n        # This would check action feedback or other completion criteria\n        return True  # Placeholder logic\n\n    def emergency_stop(self):\n        """Execute emergency stop procedures."""\n        self.robot_mode = \'safe_mode\'\n        self.current_behavior = \'emergency_stop\'\n\n        # Stop all movement\n        stop_cmd = Twist()\n        self.cmd_vel_pub.publish(stop_cmd)\n\n        self.get_logger().error(\'EMERGENCY STOP ACTIVATED\')\n\n    def send_walk_command(self, x, y):\n        """Send a walk command to the action server."""\n        if not self.walk_action_client.wait_for_server(timeout_sec=1.0):\n            self.get_logger().error(\'Walk action server not available\')\n            return False\n\n        goal_msg = WalkToPose.Goal()\n        goal_msg.target_pose.position.x = x\n        goal_msg.target_pose.position.y = y\n        goal_msg.target_pose.orientation.w = 1.0\n        goal_msg.step_size = 0.1\n        goal_msg.max_steps = 100\n\n        future = self.walk_action_client.send_goal_async(goal_msg)\n        return future\n\n\ndef main(args=None):\n    """Main function to run the behavior manager."""\n    rclpy.init(args=args)\n\n    node = BehaviorManager()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})})}),(0,s.jsxs)(a.A,{value:"explanation",label:"Explanation",children:[(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"System Integration Explanation:"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The launch file coordinates multiple nodes to start the complete system"}),"\n",(0,s.jsx)(n.li,{children:"The behavior manager acts as a central coordinator using various ROS 2 patterns"}),"\n",(0,s.jsx)(n.li,{children:"Service servers allow external systems to query and control robot state"}),"\n",(0,s.jsx)(n.li,{children:"Action clients enable complex, long-running behaviors"}),"\n",(0,s.jsx)(n.li,{children:"Safety checks are implemented throughout the system"}),"\n"]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Key Integration Elements:"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Launch Files"}),": Coordinate system startup with proper parameter configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Management"}),": Track robot mode and behavior state across the system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety Systems"}),": Monitor conditions and implement emergency procedures"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Communication"}),": Combine topics, services, and actions appropriately"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modularity"}),": Each component has a specific responsibility"]}),"\n"]}),(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Expected:"})}),(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Complete system with coordinated behavior"}),"\n",(0,s.jsx)(n.li,{children:"Proper error handling and safety procedures"}),"\n",(0,s.jsx)(n.li,{children:"Scalable architecture that can accommodate additional capabilities"}),"\n"]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"example-2-parameter-management-and-system-configuration",children:"Example 2: Parameter Management and System Configuration"}),"\n",(0,s.jsxs)(r.A,{children:[(0,s.jsx)(a.A,{value:"param_file",label:"Parameter YAML File",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'# Configuration file for humanoid robot system\n/**:\n  ros__parameters:\n    use_sim_time: false\n    robot_name: "simple_humanoid"\n    control_frequency: 500\n    safety_limits:\n      max_joint_velocity: 5.0\n      max_joint_effort: 100.0\n      max_tilt_angle: 0.5\n    system_modes:\n      - "normal"\n      - "calibration"\n      - "safe_mode"\n      - "maintenance"\n\nrobot_state_publisher:\n  ros__parameters:\n    publish_frequency: 50.0\n    ignore_timestamp: false\n\njoint_state_publisher:\n  ros__parameters:\n    rate: 50\n    source_list: ["joint_states_desired", "joint_states_actual"]\n\nbalance_controller:\n  ros__parameters:\n    control_frequency: 500\n    pid_gains:\n      kp: 50.0\n      ki: 0.1\n      kd: 10.0\n    balance_threshold: 0.1\n    max_correction: 0.5\n\nbehavior_manager:\n  ros__parameters:\n    default_behavior: "idle"\n    behavior_timeout: 30.0\n    safety_check_frequency: 10.0\n    emergency_stop_conditions:\n      - "excessive_tilt"\n      - "joint_limit_violation"\n      - "communication_timeout"\n'})})}),(0,s.jsx)(a.A,{value:"param_node",label:"Parameter-Driven Node",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n# Example: Parameter-driven system node with runtime configuration\n\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.parameter import Parameter\nfrom rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nimport json\n\n\nclass ConfigurableSystemNode(Node):\n    \"\"\"\n    A system node that uses parameters for configuration and supports dynamic reconfiguration.\n    Demonstrates parameter management in integrated systems.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('configurable_system_node')\n\n        # Declare parameters with default values\n        self.declare_parameter('control_frequency', 100)\n        self.declare_parameter('safety_limits.max_joint_velocity', 5.0)\n        self.declare_parameter('safety_limits.max_joint_effort', 100.0)\n        self.declare_parameter('safety_limits.max_tilt_angle', 0.5)\n        self.declare_parameter('debug_mode', False)\n        self.declare_parameter('enabled_modules', ['perception', 'control', 'planning'])\n\n        # Get parameter values\n        self.control_frequency = self.get_parameter('control_frequency').value\n        self.max_joint_velocity = self.get_parameter('safety_limits.max_joint_velocity').value\n        self.max_joint_effort = self.get_parameter('safety_limits.max_joint_effort').value\n        self.max_tilt_angle = self.get_parameter('safety_limits.max_tilt_angle').value\n        self.debug_mode = self.get_parameter('debug_mode').value\n        self.enabled_modules = self.get_parameter('enabled_modules').value\n\n        # Create timer based on control frequency\n        timer_period = 1.0 / self.control_frequency\n        self.control_timer = self.create_timer(timer_period, self.control_loop)\n\n        # Create subscribers and publishers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        self.control_cmd_pub = self.create_publisher(\n            Float64MultiArray,\n            '/joint_group_position_controller/commands',\n            10\n        )\n\n        # Add parameter callback to handle dynamic reconfiguration\n        self.add_on_set_parameters_callback(self.parameter_callback)\n\n        self.get_logger().info(f'Configurable System Node initialized with {self.control_frequency}Hz control rate')\n\n    def parameter_callback(self, params):\n        \"\"\"Handle parameter changes at runtime.\"\"\"\n        successful = True\n        reason = ''\n\n        for param in params:\n            if param.name == 'control_frequency' and param.type_ == Parameter.Type.INTEGER:\n                self.control_frequency = param.value\n                # Adjust timer period\n                timer_period = 1.0 / self.control_frequency\n                self.control_timer.timer_period_ns = int(timer_period * 1e9)\n                self.get_logger().info(f'Control frequency updated to {self.control_frequency}Hz')\n            elif param.name == 'safety_limits.max_joint_velocity':\n                self.max_joint_velocity = param.value\n                self.get_logger().info(f'Max joint velocity updated to {self.max_joint_velocity}')\n            elif param.name == 'debug_mode':\n                self.debug_mode = param.value\n                self.get_logger().info(f'Debug mode set to {self.debug_mode}')\n\n        return SetParametersResult(successful=successful, reason=reason)\n\n    def control_loop(self):\n        \"\"\"Main control loop that uses configured parameters.\"\"\"\n        if self.debug_mode:\n            self.get_logger().debug(f'Control loop running at {self.control_frequency}Hz')\n\n        # Example control logic using parameters\n        if 'control' in self.enabled_modules:\n            self.execute_control_logic()\n\n    def joint_state_callback(self, msg):\n        \"\"\"Handle joint state updates with parameter-based validation.\"\"\"\n        for i, (name, pos, vel, eff) in enumerate(zip(msg.name, msg.position, msg.velocity, msg.effort)):\n            # Check safety limits using parameters\n            if abs(vel) > self.max_joint_velocity:\n                self.get_logger().warn(f'Joint {name} velocity limit exceeded: {vel} > {self.max_joint_velocity}')\n\n            if abs(eff) > self.max_joint_effort:\n                self.get_logger().warn(f'Joint {name} effort limit exceeded: {eff} > {self.max_joint_effort}')\n\n    def execute_control_logic(self):\n        \"\"\"Execute control logic based on system parameters.\"\"\"\n        # This would contain the actual control algorithm\n        # For example, a PD controller using parameter-defined gains\n        pass\n\n    def get_system_status(self):\n        \"\"\"Get current system status based on parameters and state.\"\"\"\n        status = {\n            'control_frequency': self.control_frequency,\n            'max_joint_velocity': self.max_joint_velocity,\n            'max_joint_effort': self.max_joint_effort,\n            'debug_mode': self.debug_mode,\n            'enabled_modules': self.enabled_modules,\n            'active': True\n        }\n        return status\n\n\ndef main(args=None):\n    \"\"\"Main function to run the configurable system node.\"\"\"\n    rclpy.init(args=args)\n\n    node = ConfigurableSystemNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})})})]}),"\n",(0,s.jsx)(n.h2,{id:"exercises-and-checkpoints",children:"Exercises and Checkpoints"}),"\n",(0,s.jsx)(n.h3,{id:"exercise-1-system-architecture-design",children:"Exercise 1: System Architecture Design"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Scenario:"})," You're tasked with designing the software architecture for a humanoid robot that needs to:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Walk to specified locations"}),"\n",(0,s.jsx)(n.li,{children:"Manipulate objects"}),"\n",(0,s.jsx)(n.li,{children:"Respond to voice commands"}),"\n",(0,s.jsx)(n.li,{children:"Navigate around obstacles"}),"\n",(0,s.jsx)(n.li,{children:"Maintain balance"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Task:"})," Design a system architecture that integrates all these capabilities, considering:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Which components should be separate nodes"}),"\n",(0,s.jsx)(n.li,{children:"How they should communicate (topics, services, actions)"}),"\n",(0,s.jsx)(n.li,{children:"What parameters each component needs"}),"\n",(0,s.jsx)(n.li,{children:"How to handle system startup and shutdown"}),"\n",(0,s.jsx)(n.li,{children:"Safety considerations for each subsystem"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Success Criteria:"})}),"\n",(0,s.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Clear separation of concerns with appropriate modularity"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Proper communication patterns for each interaction"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Comprehensive parameter management"]}),"\n",(0,s.jsxs)(n.li,{className:"task-list-item",children:[(0,s.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Safety systems integrated throughout"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"exercise-2-practical-implementation",children:"Exercise 2: Practical Implementation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Objective:"})," Create a launch file and main system node that integrates multiple robot capabilities."]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Create a launch file that starts multiple coordinated nodes"}),"\n",(0,s.jsx)(n.li,{children:"Implement a main system node that coordinates between subsystems"}),"\n",(0,s.jsx)(n.li,{children:"Add parameter management for system configuration"}),"\n",(0,s.jsx)(n.li,{children:"Include safety checks and emergency procedures"}),"\n",(0,s.jsx)(n.li,{children:"Test the system integration with simulated components"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Expected Outcome:"})," Working integrated system with coordinated behavior and safety management."]}),"\n",(0,s.jsx)(n.h3,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Question:"})," What are the main benefits of using launch files in robotic systems?\n",(0,s.jsx)(n.strong,{children:"Answer:"})," Launch files allow coordinated startup of multiple nodes, centralized parameter configuration, dependency management, and reproducible system deployments."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Question:"})," How do you handle system-wide parameter changes during runtime?\n",(0,s.jsx)(n.strong,{children:"Answer:"})," Use ROS 2's parameter system with callback functions that can modify node behavior when parameters change, allowing dynamic reconfiguration without restarting nodes."]}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Question:"})," What is the role of a behavior manager in a humanoid robot system?\n",(0,s.jsx)(n.strong,{children:"Answer:"})," A behavior manager coordinates high-level robot behaviors, manages state transitions, ensures safety conditions are met, and provides a centralized interface for system control."]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"summary-and-key-takeaways",children:"Summary and Key Takeaways"}),"\n",(0,s.jsx)(n.h3,{id:"key-concepts-recap",children:"Key Concepts Recap"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System Integration"}),": Combining individual components into a cohesive robot system"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Architectural Patterns"}),": Layered, component-based, service-oriented, and event-driven approaches"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Launch Files"}),": Coordinating system startup and configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Parameter Management"}),": Centralized configuration with runtime reconfiguration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety Systems"}),": Integrated safety checks throughout the robot system"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Coordinated Control"}),": Multiple subsystems working together toward common goals"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"System Monitoring"}),": Comprehensive system state awareness and debugging"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Scalability"}),": Architecture that can accommodate new capabilities"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Robustness"}),": Error handling and graceful degradation when components fail"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Module Progression:"})," Complete Module 1 with ",(0,s.jsx)(n.a,{href:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/exercises-checkpoints",children:"Exercises and Checkpoints"})," (to be created)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Further Reading:"})," Explore advanced system integration patterns and middleware considerations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Practice Opportunities:"})," Build complete robot systems with multiple integrated capabilities"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"common-mistakes-and-troubleshooting",children:"Common Mistakes and Troubleshooting"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mistake 1:"})," Creating monolithic nodes instead of modular components \u2192 ",(0,s.jsx)(n.strong,{children:"Solution:"})," Break functionality into focused, single-responsibility nodes"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mistake 2:"})," Not planning for system-wide safety \u2192 ",(0,s.jsx)(n.strong,{children:"Solution:"})," Integrate safety checks throughout the system architecture"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mistake 3:"})," Poor parameter organization \u2192 ",(0,s.jsx)(n.strong,{children:"Solution:"})," Use hierarchical parameter structures and configuration files"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"references-and-resources",children:"References and Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Launch-system.html",children:"ROS 2 Launch System"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Parameters/Understanding-ROS2-Parameters.html",children:"ROS 2 Parameters Guide"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Releases/Release-Humble-Hawksbill.html",children:"ROS 2 System Architecture Patterns"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://design.ros2.org/",children:"Robot Framework Design Guidelines"})}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}}}]);