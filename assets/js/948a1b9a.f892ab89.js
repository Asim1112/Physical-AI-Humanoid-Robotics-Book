"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[8758],{2196(e,s,n){n.r(s),n.d(s,{assets:()=>h,contentTitle:()=>c,default:()=>p,frontMatter:()=>l,metadata:()=>d,toc:()=>m});var i=n(4848),t=n(8453),o=n(4252),r=n(1470),a=n(9365);const l={title:"Nodes and Topics",description:"Learn about ROS 2 nodes and the publish-subscribe communication pattern using topics",tags:["ros2","nodes","topics","communication","publish-subscribe"],sidebar_label:"Nodes and Topics",sidebar_position:3,keywords:["ros2","nodes","topics","publish-subscribe","communication"],toc_min_heading_level:2,toc_max_heading_level:4},c="Nodes and Topics",d={id:"module-1-ros2/nodes-topics",title:"Nodes and Topics",description:"Learn about ROS 2 nodes and the publish-subscribe communication pattern using topics",source:"@site/docs/module-1-ros2/nodes-topics.mdx",sourceDirName:"module-1-ros2",slug:"/module-1-ros2/nodes-topics",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/nodes-topics",draft:!1,unlisted:!1,editUrl:"https://github.com/Asim1112/Physical-AI-Humanoid-Robotics-Book/edit/main/frontend/docs/module-1-ros2/nodes-topics.mdx",tags:[{label:"ros2",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/ros-2"},{label:"nodes",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/nodes"},{label:"topics",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/topics"},{label:"communication",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/communication"},{label:"publish-subscribe",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/publish-subscribe"}],version:"current",sidebarPosition:3,frontMatter:{title:"Nodes and Topics",description:"Learn about ROS 2 nodes and the publish-subscribe communication pattern using topics",tags:["ros2","nodes","topics","communication","publish-subscribe"],sidebar_label:"Nodes and Topics",sidebar_position:3,keywords:["ros2","nodes","topics","publish-subscribe","communication"],toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"tutorialSidebar",previous:{title:"Understanding ROS 2",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/understanding-ros2"},next:{title:"Services and Actions",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/services-actions"}},h={},m=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Deep Explanation",id:"deep-explanation",level:2},{value:"Node-Topic Architecture",id:"node-topic-architecture",level:3},{value:"Quality of Service (QoS) Settings",id:"quality-of-service-qos-settings",level:3},{value:"Topic Naming Conventions",id:"topic-naming-conventions",level:3},{value:"Message Types",id:"message-types",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Basic Publisher-Subscriber Pair",id:"example-1-basic-publisher-subscriber-pair",level:3},{value:"Example 2: Multiple Publishers and Subscribers",id:"example-2-multiple-publishers-and-subscribers",level:3},{value:"Exercises and Checkpoints",id:"exercises-and-checkpoints",level:2},{value:"Exercise 1: Topic Design for Humanoid Robot",id:"exercise-1-topic-design-for-humanoid-robot",level:3},{value:"Exercise 2: Practical Implementation",id:"exercise-2-practical-implementation",level:3},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:3},{value:"Summary and Key Takeaways",id:"summary-and-key-takeaways",level:2},{value:"Key Concepts Recap",id:"key-concepts-recap",level:3},{value:"Practical Applications",id:"practical-applications",level:3},{value:"Next Steps",id:"next-steps",level:3},{value:"Common Mistakes and Troubleshooting",id:"common-mistakes-and-troubleshooting",level:3},{value:"References and Resources",id:"references-and-resources",level:3}];function u(e){const s={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.h1,{id:"nodes-and-topics",children:"Nodes and Topics"}),"\n","\n","\n",(0,i.jsx)(o.A,{toc:m}),"\n",(0,i.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(s.p,{children:"In this chapter, we'll dive deep into the fundamental communication pattern in ROS 2: nodes and topics. This publish-subscribe model is the backbone of most robotic systems and is essential for understanding how different components of a humanoid robot communicate with each other."}),"\n",(0,i.jsx)(s.p,{children:"The node-topic pattern enables asynchronous, decoupled communication between different parts of your robot. This chapter will cover how to create nodes, define topics, publish and subscribe to messages, and understand the quality of service (QoS) settings that affect communication reliability."}),"\n",(0,i.jsx)(s.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Understand the node-topic communication pattern in ROS 2"}),"\n",(0,i.jsx)(s.li,{children:"Create nodes that publish data to topics"}),"\n",(0,i.jsx)(s.li,{children:"Create nodes that subscribe to topics and process messages"}),"\n",(0,i.jsx)(s.li,{children:"Configure Quality of Service (QoS) settings for different communication needs"}),"\n",(0,i.jsx)(s.li,{children:"Design effective topic naming conventions for humanoid robotics"}),"\n",(0,i.jsx)(s.li,{children:"Debug common issues with node-topic communication"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Understanding of basic ROS 2 concepts from the previous chapter"}),"\n",(0,i.jsx)(s.li,{children:"Basic Python programming knowledge"}),"\n",(0,i.jsx)(s.li,{children:"Completed the Lab Setup section"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"deep-explanation",children:"Deep Explanation"}),"\n",(0,i.jsx)(s.h3,{id:"node-topic-architecture",children:"Node-Topic Architecture"}),"\n",(0,i.jsx)(s.p,{children:"The node-topic architecture in ROS 2 implements the publish-subscribe pattern, which is ideal for streaming data between components. In this pattern:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Publishers"})," send messages to topics without knowing who will receive them"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Subscribers"})," receive messages from topics without knowing who sent them"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Topics"})," serve as named buses that connect publishers and subscribers"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"For humanoid robots, this pattern is perfect for continuous data streams like:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Sensor data (camera images, LiDAR scans, IMU readings)"}),"\n",(0,i.jsx)(s.li,{children:"Joint state information"}),"\n",(0,i.jsx)(s.li,{children:"Robot pose estimates"}),"\n",(0,i.jsx)(s.li,{children:"Path planning updates"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"quality-of-service-qos-settings",children:"Quality of Service (QoS) Settings"}),"\n",(0,i.jsx)(s.p,{children:"ROS 2 provides Quality of Service (QoS) settings that allow you to tune communication behavior for different requirements. Key QoS settings include:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Reliability"}),": Whether messages must be delivered (RELIABLE) or can be dropped (BEST_EFFORT)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Durability"}),": Whether late-joining subscribers get old messages (TRANSIENT_LOCAL) or only new ones (VOLATILE)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"History"}),": How many messages to keep in the queue (KEEP_ALL or KEEP_LAST with a specific depth)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Deadline"}),": Maximum time between messages before considering the publisher dead"]}),"\n"]}),"\n",(0,i.jsx)(s.p,{children:"For humanoid robots, you'll often use:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"BEST_EFFORT for sensor data where occasional dropped messages are acceptable"}),"\n",(0,i.jsx)(s.li,{children:"RELIABLE for critical control commands"}),"\n",(0,i.jsx)(s.li,{children:"KEEP_LAST with small depth for real-time control data"}),"\n",(0,i.jsx)(s.li,{children:"KEEP_ALL for logging and debugging"}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"topic-naming-conventions",children:"Topic Naming Conventions"}),"\n",(0,i.jsx)(s.p,{children:"ROS 2 uses a hierarchical namespace for topics. For humanoid robotics, we recommend these conventions:"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Use descriptive names: ",(0,i.jsx)(s.code,{children:"/head_camera/image_raw"})," instead of ",(0,i.jsx)(s.code,{children:"/img"})]}),"\n",(0,i.jsxs)(s.li,{children:["Group related topics: ",(0,i.jsx)(s.code,{children:"/left_arm/joint_states"}),", ",(0,i.jsx)(s.code,{children:"/right_arm/joint_states"})]}),"\n",(0,i.jsxs)(s.li,{children:["Use underscores for multi-word topics: ",(0,i.jsx)(s.code,{children:"/robot_status"}),", not ",(0,i.jsx)(s.code,{children:"/robotstatus"})]}),"\n",(0,i.jsxs)(s.li,{children:["Prefix with robot name for multi-robot systems: ",(0,i.jsx)(s.code,{children:"/robot1/joint_states"}),", ",(0,i.jsx)(s.code,{children:"/robot2/joint_states"})]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"message-types",children:"Message Types"}),"\n",(0,i.jsxs)(s.p,{children:["Messages in ROS 2 have standardized types defined in ",(0,i.jsx)(s.code,{children:".msg"})," files. Common message types for humanoid robotics include:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"std_msgs"}),": Basic types (Int32, Float64, String, etc.)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"sensor_msgs"}),": Sensor data (Image, JointState, Imu, LaserScan)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"geometry_msgs"}),": Geometric data (Pose, Twist, Vector3, Point)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.code,{children:"nav_msgs"}),": Navigation data (Odometry, Path, OccupancyGrid)"]}),"\n",(0,i.jsx)(s.li,{children:"Custom message types for specific robot applications"}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(s.h3,{id:"example-1-basic-publisher-subscriber-pair",children:"Example 1: Basic Publisher-Subscriber Pair"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(a.A,{value:"publisher",label:"Publisher Code",default:!0,children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:"#!/usr/bin/env python3\n# Example: Basic publisher for humanoid robot joint states\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Header\nimport math\nimport time\n\n\nclass JointStatePublisher(Node):\n    \"\"\"\n    A publisher node that simulates joint state data for a humanoid robot.\n    This demonstrates basic topic publishing with QoS configuration.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('joint_state_publisher')\n\n        # Create publisher with QoS settings\n        self.publisher = self.create_publisher(\n            JointState,\n            '/joint_states',\n            10  # Queue size\n        )\n\n        # Timer to publish joint states at 50Hz\n        self.timer = self.create_timer(0.02, self.publish_joint_states)\n\n        # Simulate joint positions\n        self.time_offset = time.time()\n\n        self.get_logger().info('Joint State Publisher node initialized')\n\n    def publish_joint_states(self):\n        \"\"\"Publish simulated joint state data.\"\"\"\n        msg = JointState()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = 'base_link'\n\n        # Define joint names for a simple humanoid (6 DOF example)\n        msg.name = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint'\n        ]\n\n        # Calculate positions with simple oscillating pattern\n        t = time.time() - self.time_offset\n        positions = [\n            0.2 * math.sin(t * 0.5),    # left_hip_joint\n            0.1 * math.sin(t * 0.7),    # left_knee_joint\n            0.15 * math.sin(t * 0.3),   # left_ankle_joint\n            0.2 * math.sin(t * 0.5),    # right_hip_joint\n            0.1 * math.sin(t * 0.7),    # right_knee_joint\n            0.15 * math.sin(t * 0.3)    # right_ankle_joint\n        ]\n\n        msg.position = positions\n\n        # Set velocities and efforts to zero for this example\n        msg.velocity = [0.0] * len(positions)\n        msg.effort = [0.0] * len(positions)\n\n        self.publisher.publish(msg)\n        self.get_logger().debug(f'Published joint states: {positions}')\n\n\ndef main(args=None):\n    \"\"\"Main function to run the joint state publisher node.\"\"\"\n    rclpy.init(args=args)\n\n    publisher = JointStatePublisher()\n\n    try:\n        rclpy.spin(publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        publisher.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})})}),(0,i.jsx)(a.A,{value:"subscriber",label:"Subscriber Code",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Example: Basic subscriber for humanoid robot joint states\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n\n\nclass JointStateSubscriber(Node):\n    """\n    A subscriber node that receives and processes joint state data.\n    This demonstrates basic topic subscription and message processing.\n    """\n\n    def __init__(self):\n        super().__init__(\'joint_state_subscriber\')\n\n        # Create subscriber with default QoS\n        self.subscription = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10  # Queue size\n        )\n\n        self.get_logger().info(\'Joint State Subscriber node initialized\')\n\n    def joint_state_callback(self, msg):\n        """Process incoming joint state messages."""\n        # Log basic information about the received joint states\n        self.get_logger().info(\n            f\'Received {len(msg.name)} joint states: {msg.name[:3]}...\'  # Show first 3 names\n        )\n\n        # Process each joint state\n        for i, (name, pos) in enumerate(zip(msg.name, msg.position)):\n            # Simple safety check - if position is too extreme, log a warning\n            if abs(pos) > 2.0:  # Assuming radians, 2.0 is a reasonable limit\n                self.get_logger().warn(f\'Joint {name} has extreme position: {pos:.3f}\')\n\n        # Calculate and log average position\n        if msg.position:\n            avg_pos = sum(msg.position) / len(msg.position)\n            self.get_logger().info(f\'Average joint position: {avg_pos:.3f}\')\n\n\ndef main(args=None):\n    """Main function to run the joint state subscriber node."""\n    rclpy.init(args=args)\n\n    subscriber = JointStateSubscriber()\n\n    try:\n        rclpy.spin(subscriber)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        subscriber.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})})}),(0,i.jsxs)(a.A,{value:"explanation",label:"Explanation",children:[(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Publisher Explanation:"})}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Creates a publisher for the ",(0,i.jsx)(s.code,{children:"/joint_states"})," topic with JointState message type"]}),"\n",(0,i.jsx)(s.li,{children:"Uses a timer to publish at 50Hz (every 20ms) for real-time control"}),"\n",(0,i.jsx)(s.li,{children:"Simulates joint positions with oscillating patterns"}),"\n",(0,i.jsx)(s.li,{children:"Properly sets header information including timestamp"}),"\n",(0,i.jsx)(s.li,{children:"Includes position, velocity, and effort data as required by JointState message"}),"\n"]}),(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Subscriber Explanation:"})}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:["Creates a subscriber for the ",(0,i.jsx)(s.code,{children:"/joint_states"})," topic"]}),"\n",(0,i.jsx)(s.li,{children:"Processes joint names and positions from received messages"}),"\n",(0,i.jsx)(s.li,{children:"Includes safety checks for extreme joint positions"}),"\n",(0,i.jsx)(s.li,{children:"Calculates and logs average joint position for monitoring"}),"\n"]}),(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Expected:"})}),(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Publisher continuously sends joint state messages at 50Hz"}),"\n",(0,i.jsx)(s.li,{children:"Subscriber receives and processes messages in real-time"}),"\n",(0,i.jsx)(s.li,{children:"Both nodes can run independently and communicate via ROS 2"}),"\n"]})]})]}),"\n",(0,i.jsx)(s.h3,{id:"example-2-multiple-publishers-and-subscribers",children:"Example 2: Multiple Publishers and Subscribers"}),"\n",(0,i.jsxs)(r.A,{children:[(0,i.jsx)(a.A,{value:"multi_publisher",label:"Multi-Publisher Code",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Example: Multiple publishers for different humanoid robot sensors\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu, Image\nfrom std_msgs.msg import Header, String\nimport math\nimport time\nimport numpy as np\n\n\nclass MultiSensorPublisher(Node):\n    """\n    A publisher node that simulates multiple sensor streams for a humanoid robot.\n    Demonstrates publishing to multiple topics from a single node.\n    """\n\n    def __init__(self):\n        super().__init__(\'multi_sensor_publisher\')\n\n        # Create publishers for different sensor types\n        self.joint_pub = self.create_publisher(JointState, \'/joint_states\', 10)\n        self.imu_pub = self.create_publisher(Imu, \'/imu/data\', 10)\n        self.status_pub = self.create_publisher(String, \'/robot_status\', 10)\n\n        # Timers for different sensor update rates\n        self.joint_timer = self.create_timer(0.02, self.publish_joint_states)  # 50Hz\n        self.imu_timer = self.create_timer(0.01, self.publish_imu_data)       # 100Hz\n        self.status_timer = self.create_timer(1.0, self.publish_status)       # 1Hz\n\n        self.time_offset = time.time()\n\n        self.get_logger().info(\'Multi-Sensor Publisher node initialized\')\n\n    def publish_joint_states(self):\n        """Publish simulated joint state data."""\n        msg = JointState()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'base_link\'\n\n        msg.name = [\'hip_joint\', \'knee_joint\', \'ankle_joint\']\n\n        t = time.time() - self.time_offset\n        positions = [\n            0.1 * math.sin(t * 0.5),\n            0.05 * math.sin(t * 0.7),\n            0.08 * math.sin(t * 0.3)\n        ]\n\n        msg.position = positions\n        msg.velocity = [0.0] * len(positions)\n        msg.effort = [0.0] * len(positions)\n\n        self.joint_pub.publish(msg)\n\n    def publish_imu_data(self):\n        """Publish simulated IMU data."""\n        msg = Imu()\n        msg.header = Header()\n        msg.header.stamp = self.get_clock().now().to_msg()\n        msg.header.frame_id = \'imu_link\'\n\n        t = time.time() - self.time_offset\n\n        # Simulate orientation (using simple oscillation)\n        msg.orientation.x = 0.0\n        msg.orientation.y = 0.1 * math.sin(t * 0.2)\n        msg.orientation.z = 0.05 * math.sin(t * 0.1)\n        msg.orientation.w = math.sqrt(1 -\n            msg.orientation.x**2 -\n            msg.orientation.y**2 -\n            msg.orientation.z**2)\n\n        # Simulate angular velocity\n        msg.angular_velocity.x = 0.05 * math.cos(t * 0.2)\n        msg.angular_velocity.y = 0.02 * math.cos(t * 0.1)\n        msg.angular_velocity.z = 0.01 * math.cos(t * 0.3)\n\n        # Simulate linear acceleration\n        msg.linear_acceleration.x = 0.5 * math.sin(t * 0.3)\n        msg.linear_acceleration.y = 0.2 * math.sin(t * 0.4)\n        msg.linear_acceleration.z = 9.81 + 0.1 * math.sin(t * 0.5)  # Gravity + small variation\n\n        self.imu_pub.publish(msg)\n\n    def publish_status(self):\n        """Publish robot status."""\n        msg = String()\n        t = time.time() - self.time_offset\n        msg.data = f\'Nominal operation - time: {t:.2f}s\'\n        self.status_pub.publish(msg)\n\n\ndef main(args=None):\n    """Main function to run the multi-sensor publisher node."""\n    rclpy.init(args=args)\n\n    publisher = MultiSensorPublisher()\n\n    try:\n        rclpy.spin(publisher)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        publisher.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})})}),(0,i.jsx)(a.A,{value:"multi_subscriber",label:"Multi-Subscriber Code",children:(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Example: Multi-topic subscriber that listens to multiple robot data streams\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState, Imu\nfrom std_msgs.msg import String\n\n\nclass MultiTopicSubscriber(Node):\n    """\n    A subscriber node that receives data from multiple topics.\n    Demonstrates handling multiple subscriptions in a single node.\n    """\n\n    def __init__(self):\n        super().__init__(\'multi_topic_subscriber\')\n\n        # Create subscribers for different topics\n        self.joint_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        self.imu_sub = self.create_subscription(\n            Imu,\n            \'/imu/data\',\n            self.imu_callback,\n            10\n        )\n\n        self.status_sub = self.create_subscription(\n            String,\n            \'/robot_status\',\n            self.status_callback,\n            10\n        )\n\n        # Store latest values for correlation\n        self.latest_joint_positions = []\n        self.latest_orientation = None\n\n        self.get_logger().info(\'Multi-Topic Subscriber node initialized\')\n\n    def joint_state_callback(self, msg):\n        """Process joint state messages."""\n        self.latest_joint_positions = msg.position\n        avg_pos = sum(msg.position) / len(msg.position) if msg.position else 0.0\n\n        self.get_logger().info(\n            f\'Joint states - Avg pos: {avg_pos:.3f}, Count: {len(msg.name)}\'\n        )\n\n    def imu_callback(self, msg):\n        """Process IMU messages."""\n        # Extract orientation information\n        self.latest_orientation = {\n            \'x\': msg.orientation.x,\n            \'y\': msg.orientation.y,\n            \'z\': msg.orientation.z,\n            \'w\': msg.orientation.w\n        }\n\n        # Calculate roll, pitch, yaw approximation\n        pitch = math.asin(2 * (msg.orientation.w * msg.orientation.y -\n                              msg.orientation.z * msg.orientation.x))\n\n        self.get_logger().info(\n            f\'IMU - Pitch: {math.degrees(pitch):.2f}\xb0, \'\n            f\'Linear Z: {msg.linear_acceleration.z:.2f}\'\n        )\n\n    def status_callback(self, msg):\n        """Process status messages."""\n        self.get_logger().info(f\'Status: {msg.data}\')\n\n\ndef main(args=None):\n    """Main function to run the multi-topic subscriber node."""\n    rclpy.init(args=args)\n\n    subscriber = MultiTopicSubscriber()\n\n    try:\n        rclpy.spin(subscriber)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        subscriber.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})})})]}),"\n",(0,i.jsx)(s.h2,{id:"exercises-and-checkpoints",children:"Exercises and Checkpoints"}),"\n",(0,i.jsx)(s.h3,{id:"exercise-1-topic-design-for-humanoid-robot",children:"Exercise 1: Topic Design for Humanoid Robot"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Scenario:"})," You're designing a humanoid robot with the following subsystems:"]}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:"Head with camera and pan/tilt mechanism"}),"\n",(0,i.jsx)(s.li,{children:"Two arms with 7 DOF each"}),"\n",(0,i.jsx)(s.li,{children:"Two legs with 6 DOF each"}),"\n",(0,i.jsx)(s.li,{children:"IMU for balance"}),"\n",(0,i.jsx)(s.li,{children:"Force/torque sensors in feet"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Task:"})," Design a topic naming scheme that follows ROS 2 conventions and makes the system easy to understand and maintain."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Success Criteria:"})}),"\n",(0,i.jsxs)(s.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","All topics follow consistent naming conventions"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Related topics are grouped logically"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Names are descriptive and unambiguous"]}),"\n",(0,i.jsxs)(s.li,{className:"task-list-item",children:[(0,i.jsx)(s.input,{type:"checkbox",disabled:!0})," ","Consider QoS requirements for different topics"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"exercise-2-practical-implementation",children:"Exercise 2: Practical Implementation"}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Objective:"})," Create a publisher-subscriber pair that simulates a humanoid robot's head pan-tilt system."]}),"\n",(0,i.jsx)(s.p,{children:(0,i.jsx)(s.strong,{children:"Steps:"})}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["Create a publisher that publishes head joint positions to ",(0,i.jsx)(s.code,{children:"/head_controller/joint_states"})]}),"\n",(0,i.jsx)(s.li,{children:"Create a subscriber that listens to these positions and logs them"}),"\n",(0,i.jsx)(s.li,{children:"Add a safety check that prevents extreme head movements (>30 degrees)"}),"\n",(0,i.jsx)(s.li,{children:"Test both nodes can communicate properly"}),"\n"]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Expected Outcome:"})," Working publisher-subscriber pair with safety validation."]}),"\n",(0,i.jsx)(s.h3,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,i.jsxs)(s.ol,{children:["\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Question:"})," What is the main advantage of the publish-subscribe pattern over direct function calls in robotic systems?\n",(0,i.jsx)(s.strong,{children:"Answer:"})," Decoupling - publishers don't need to know who subscribes to their data, and subscribers don't need to know who publishes the data they receive. This enables modular, flexible system design."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Question:"})," When would you use BEST_EFFORT vs RELIABLE QoS for a topic?\n",(0,i.jsx)(s.strong,{children:"Answer:"})," Use BEST_EFFORT for sensor data where occasional dropped messages are acceptable (e.g., camera images), and RELIABLE for critical control commands where every message must be delivered."]}),"\n"]}),"\n",(0,i.jsxs)(s.li,{children:["\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.strong,{children:"Question:"})," What's the difference between KEEP_ALL and KEEP_LAST in QoS history policy?\n",(0,i.jsx)(s.strong,{children:"Answer:"})," KEEP_ALL stores all messages in the queue (limited by memory), while KEEP_LAST stores only the last N messages (where N is specified)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(s.h2,{id:"summary-and-key-takeaways",children:"Summary and Key Takeaways"}),"\n",(0,i.jsx)(s.h3,{id:"key-concepts-recap",children:"Key Concepts Recap"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Publish-Subscribe Pattern"}),": Asynchronous communication between nodes through named topics"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Quality of Service (QoS)"}),": Settings that control message delivery behavior (reliability, durability, history, deadline)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Topic Naming"}),": Hierarchical naming scheme that groups related functionality"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Message Types"}),": Standardized formats for data exchange between nodes"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Node Independence"}),": Publishers and subscribers can run independently without direct coupling"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Sensor Data"}),": Camera images, LiDAR scans, IMU readings using appropriate QoS"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Control Systems"}),": Joint commands, velocity commands, pose references"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Monitoring"}),": Robot status, diagnostic information, system health"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Coordination"}),": Path planning updates, task status, system events"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Module Progression:"})," Next chapter covers ",(0,i.jsx)(s.a,{href:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/services-actions",children:"Services and Actions"})," for synchronous communication"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Further Reading:"})," Explore advanced QoS configurations and their impact on system performance"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Practice Opportunities:"})," Create more complex publisher-subscriber pairs for different robot subsystems"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"common-mistakes-and-troubleshooting",children:"Common Mistakes and Troubleshooting"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Mistake 1:"})," Using inappropriate QoS settings for the application \u2192 ",(0,i.jsx)(s.strong,{children:"Solution:"})," Match QoS to requirements (BEST_EFFORT for sensor data, RELIABLE for control)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Mistake 2:"})," Not considering message frequency \u2192 ",(0,i.jsx)(s.strong,{children:"Solution:"})," Match publication rate to application needs (e.g., 100Hz for control, 30Hz for video)"]}),"\n",(0,i.jsxs)(s.li,{children:[(0,i.jsx)(s.strong,{children:"Mistake 3:"})," Poor topic naming \u2192 ",(0,i.jsx)(s.strong,{children:"Solution:"})," Use descriptive, consistent names that group related functionality"]}),"\n"]}),"\n",(0,i.jsx)(s.h3,{id:"references-and-resources",children:"References and Resources"}),"\n",(0,i.jsxs)(s.ul,{children:["\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.ros.org/en/humble/Tutorials/Topics/Topics.html",children:"ROS 2 Topics and Services Guide"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.ros.org/en/humble/Concepts/About-Quality-of-Service-Settings.html",children:"Quality of Service in ROS 2"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.ros2.org/latest/api/sensor_msgs/",children:"sensor_msgs Package Documentation"})}),"\n",(0,i.jsx)(s.li,{children:(0,i.jsx)(s.a,{href:"https://docs.ros.org/en/humble/Concepts/About-ROS-Interfaces.html",children:"ROS 2 Message Types"})}),"\n"]})]})}function p(e={}){const{wrapper:s}={...(0,t.R)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}}}]);