"use strict";(globalThis.webpackChunkhumanoid_robotics_book=globalThis.webpackChunkhumanoid_robotics_book||[]).push([[5833],{9410(e,n,s){s.r(n),s.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>g,frontMatter:()=>l,metadata:()=>d,toc:()=>p});var i=s(4848),t=s(8453),r=s(4252),o=s(1470),a=s(9365);const l={title:"Services and Actions",description:"Learn about ROS 2 services for request-response communication and actions for long-running tasks with feedback",tags:["ros2","services","actions","communication","request-response","feedback"],sidebar_label:"Services and Actions",sidebar_position:4,keywords:["ros2","services","actions","request-response","feedback","goals"],toc_min_heading_level:2,toc_max_heading_level:4},c="Services and Actions",d={id:"module-1-ros2/services-actions",title:"Services and Actions",description:"Learn about ROS 2 services for request-response communication and actions for long-running tasks with feedback",source:"@site/docs/module-1-ros2/services-actions.mdx",sourceDirName:"module-1-ros2",slug:"/module-1-ros2/services-actions",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/services-actions",draft:!1,unlisted:!1,editUrl:"https://github.com/Asim1112/Physical-AI-Humanoid-Robotics-Book/edit/main/frontend/docs/module-1-ros2/services-actions.mdx",tags:[{label:"ros2",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/ros-2"},{label:"services",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/services"},{label:"actions",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/actions"},{label:"communication",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/communication"},{label:"request-response",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/request-response"},{label:"feedback",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/tags/feedback"}],version:"current",sidebarPosition:4,frontMatter:{title:"Services and Actions",description:"Learn about ROS 2 services for request-response communication and actions for long-running tasks with feedback",tags:["ros2","services","actions","communication","request-response","feedback"],sidebar_label:"Services and Actions",sidebar_position:4,keywords:["ros2","services","actions","request-response","feedback","goals"],toc_min_heading_level:2,toc_max_heading_level:4},sidebar:"tutorialSidebar",previous:{title:"Nodes and Topics",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/nodes-topics"},next:{title:"URDF Modeling",permalink:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/urdf-modeling"}},u={},p=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Deep Explanation",id:"deep-explanation",level:2},{value:"Services in ROS 2",id:"services-in-ros-2",level:3},{value:"Service Architecture",id:"service-architecture",level:3},{value:"Actions in ROS 2",id:"actions-in-ros-2",level:3},{value:"Action Architecture",id:"action-architecture",level:3},{value:"When to Use Each Pattern",id:"when-to-use-each-pattern",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Basic Service Server and Client",id:"example-1-basic-service-server-and-client",level:3},{value:"Example 2: Action Server and Client for Humanoid Walking",id:"example-2-action-server-and-client-for-humanoid-walking",level:3},{value:"Exercises and Checkpoints",id:"exercises-and-checkpoints",level:2},{value:"Exercise 1: Service vs Action Decision Matrix",id:"exercise-1-service-vs-action-decision-matrix",level:3},{value:"Exercise 2: Practical Implementation",id:"exercise-2-practical-implementation",level:3},{value:"Self-Assessment Questions",id:"self-assessment-questions",level:3},{value:"Summary and Key Takeaways",id:"summary-and-key-takeaways",level:2},{value:"Key Concepts Recap",id:"key-concepts-recap",level:3},{value:"Practical Applications",id:"practical-applications",level:3},{value:"Next Steps",id:"next-steps",level:3},{value:"Common Mistakes and Troubleshooting",id:"common-mistakes-and-troubleshooting",level:3},{value:"References and Resources",id:"references-and-resources",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",input:"input",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"services-and-actions",children:"Services and Actions"}),"\n","\n","\n",(0,i.jsx)(r.A,{toc:p}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"In this chapter, we'll explore two advanced communication patterns in ROS 2: services and actions. While topics are perfect for continuous data streams, services and actions provide different communication models for specific use cases in humanoid robotics."}),"\n",(0,i.jsx)(n.p,{children:"Services implement a request-response pattern, ideal for quick queries and commands that require a direct response. Actions are designed for long-running tasks that need to provide feedback during execution and support cancellation, making them perfect for complex humanoid robot behaviors like walking, manipulation, or navigation."}),"\n",(0,i.jsx)(n.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understand the service request-response communication pattern"}),"\n",(0,i.jsx)(n.li,{children:"Create and use custom service definitions"}),"\n",(0,i.jsx)(n.li,{children:"Implement action servers and clients for long-running tasks"}),"\n",(0,i.jsx)(n.li,{children:"Design appropriate use cases for services vs actions vs topics"}),"\n",(0,i.jsx)(n.li,{children:"Handle service and action errors gracefully"}),"\n",(0,i.jsx)(n.li,{children:"Apply services and actions to humanoid robot control scenarios"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Understanding of ROS 2 nodes and topics"}),"\n",(0,i.jsx)(n.li,{children:"Basic Python programming knowledge"}),"\n",(0,i.jsx)(n.li,{children:"Completed the previous chapters on ROS 2 fundamentals"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"deep-explanation",children:"Deep Explanation"}),"\n",(0,i.jsx)(n.h3,{id:"services-in-ros-2",children:"Services in ROS 2"}),"\n",(0,i.jsx)(n.p,{children:"Services in ROS 2 implement a synchronous request-response pattern. A service client sends a request to a service server, which processes the request and returns a response. This is perfect for operations that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Need a guaranteed response"}),"\n",(0,i.jsx)(n.li,{children:"Are relatively quick to execute"}),"\n",(0,i.jsx)(n.li,{children:"Require specific parameters and return specific results"}),"\n",(0,i.jsx)(n.li,{children:"Should block until completion"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robotics, common service use cases include:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requesting current robot state information"}),"\n",(0,i.jsx)(n.li,{children:"Enabling/disabling specific robot functions"}),"\n",(0,i.jsx)(n.li,{children:"Loading/unloading maps or configurations"}),"\n",(0,i.jsx)(n.li,{children:"Querying robot capabilities or parameters"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"service-architecture",children:"Service Architecture"}),"\n",(0,i.jsx)(n.p,{children:"A ROS 2 service consists of:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Definition (.srv file)"}),": Defines the request and response message types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Server"}),": Implements the service logic and responds to requests"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Client"}),": Sends requests to the server and receives responses"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The service definition file has two parts separated by three dashes (---):"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Request: Input parameters for the service"}),"\n",(0,i.jsx)(n.li,{children:"Response: Output parameters from the service"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"actions-in-ros-2",children:"Actions in ROS 2"}),"\n",(0,i.jsx)(n.p,{children:"Actions are designed for long-running tasks that require:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Feedback during execution"}),"\n",(0,i.jsx)(n.li,{children:"Ability to cancel the task"}),"\n",(0,i.jsx)(n.li,{children:"Goal and result messages"}),"\n",(0,i.jsx)(n.li,{children:"More complex state management than services provide"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For humanoid robots, actions are ideal for:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Walking to a specific location with progress feedback"}),"\n",(0,i.jsx)(n.li,{children:"Manipulating objects with detailed status updates"}),"\n",(0,i.jsx)(n.li,{children:"Performing complex behaviors with intermediate results"}),"\n",(0,i.jsx)(n.li,{children:"Calibrating sensors or systems with progress reporting"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"action-architecture",children:"Action Architecture"}),"\n",(0,i.jsx)(n.p,{children:"An action definition includes three message types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Goal"}),": Parameters for the action request"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Result"}),": Final outcome of the action"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Feedback"}),": Intermediate status updates during execution"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The action client-server interaction includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Goal request and acceptance/rejection"}),"\n",(0,i.jsx)(n.li,{children:"Continuous feedback during execution"}),"\n",(0,i.jsx)(n.li,{children:"Result delivery upon completion"}),"\n",(0,i.jsx)(n.li,{children:"Cancellation capability"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"when-to-use-each-pattern",children:"When to Use Each Pattern"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Topics"}),": For continuous data streams, sensor data, state broadcasting"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Services"}),": For quick, synchronous operations that return a result"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Actions"}),": For long-running tasks that need feedback and cancellation"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,i.jsx)(n.h3,{id:"example-1-basic-service-server-and-client",children:"Example 1: Basic Service Server and Client"}),"\n",(0,i.jsxs)(o.A,{children:[(0,i.jsx)(a.A,{value:"service_def",label:"Service Definition (.srv)",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# File: srv/SetJointPosition.srv\n# Request\nstring joint_name\nfloat64 position\n---\n# Response\nbool success\nstring message\n"})})}),(0,i.jsx)(a.A,{value:"server",label:"Service Server",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n# Example: Service server for setting joint positions on a humanoid robot\n\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import SetBool\nfrom std_srvs.srv import SetBool as StdSetBool\nimport time\n\n\nclass JointPositionService(Node):\n    \"\"\"\n    A service server that handles requests to set joint positions.\n    Demonstrates basic service server implementation.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('joint_position_service')\n\n        # Create a service server\n        self.srv = self.create_service(\n            StdSetBool,  # Using standard SetBool service for simplicity\n            'set_joint_torque_enabled',\n            self.set_joint_torque_callback\n        )\n\n        # Simulate current joint states\n        self.torque_enabled = True\n\n        self.get_logger().info('Joint Position Service server initialized')\n\n    def set_joint_torque_callback(self, request, response):\n        \"\"\"Handle incoming service requests to enable/disable joint torque.\"\"\"\n        self.get_logger().info(f'Received request to set torque enabled: {request.data}')\n\n        # Simulate the actual hardware operation\n        try:\n            # In a real robot, this would send commands to the joint controllers\n            self.torque_enabled = request.data\n\n            # Simulate processing time\n            time.sleep(0.1)\n\n            # Set response\n            response.success = True\n            response.message = f'Joint torque successfully set to {request.data}'\n\n            self.get_logger().info(f'Service completed successfully: {response.message}')\n\n        except Exception as e:\n            response.success = False\n            response.message = f'Failed to set joint torque: {str(e)}'\n            self.get_logger().error(f'Service failed: {str(e)}')\n\n        return response\n\n\ndef main(args=None):\n    \"\"\"Main function to run the service server.\"\"\"\n    rclpy.init(args=args)\n\n    service_node = JointPositionService()\n\n    try:\n        rclpy.spin(service_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        service_node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})})}),(0,i.jsx)(a.A,{value:"client",label:"Service Client",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Example: Service client that calls the joint position service\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_srvs.srv import SetBool\nimport sys\n\n\nclass JointPositionClient(Node):\n    """\n    A service client that calls the joint position service.\n    Demonstrates basic service client implementation.\n    """\n\n    def __init__(self):\n        super().__init__(\'joint_position_client\')\n\n        # Create a service client\n        self.cli = self.create_client(SetBool, \'set_joint_torque_enabled\')\n\n        # Wait for the service to be available\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info(\'Service not available, waiting again...\')\n\n        self.get_logger().info(\'Service client initialized\')\n\n    def send_request(self, enable_torque):\n        """Send a request to the service."""\n        request = SetBool.Request()\n        request.data = enable_torque\n\n        self.get_logger().info(f\'Sending request to set torque enabled: {enable_torque}\')\n\n        # Call the service asynchronously\n        future = self.cli.call_async(request)\n        rclpy.spin_until_future_complete(self, future)\n\n        if future.result() is not None:\n            response = future.result()\n            self.get_logger().info(\n                f\'Service response - Success: {response.success}, Message: {response.message}\'\n            )\n            return response\n        else:\n            self.get_logger().error(\'Service call failed\')\n            return None\n\n\ndef main(args=None):\n    """Main function to run the service client."""\n    rclpy.init(args=args)\n\n    client = JointPositionClient()\n\n    # Get command line argument for torque enable/disable\n    if len(sys.argv) < 2:\n        print("Usage: python3 service_client.py <true|false>")\n        return\n\n    enable_torque = sys.argv[1].lower() == \'true\'\n\n    response = client.send_request(enable_torque)\n\n    if response and response.success:\n        print(f"Successfully set torque to {enable_torque}")\n    else:\n        print(f"Failed to set torque to {enable_torque}")\n\n    client.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})})}),(0,i.jsxs)(a.A,{value:"explanation",label:"Explanation",children:[(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Service Server Explanation:"})}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Creates a service server using ",(0,i.jsx)(n.code,{children:"create_service()"})," method"]}),"\n",(0,i.jsx)(n.li,{children:"Implements a callback function that processes requests and returns responses"}),"\n",(0,i.jsx)(n.li,{children:"Handles errors gracefully and provides meaningful response messages"}),"\n",(0,i.jsx)(n.li,{children:"Uses standard SetBool service for simplicity in this example"}),"\n"]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Service Client Explanation:"})}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Creates a service client using ",(0,i.jsx)(n.code,{children:"create_client()"})," method"]}),"\n",(0,i.jsx)(n.li,{children:"Waits for the service to be available before sending requests"}),"\n",(0,i.jsxs)(n.li,{children:["Calls the service asynchronously using ",(0,i.jsx)(n.code,{children:"call_async()"})]}),"\n",(0,i.jsxs)(n.li,{children:["Waits for the response using ",(0,i.jsx)(n.code,{children:"spin_until_future_complete()"})]}),"\n"]}),(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Expected:"})}),(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Service server runs and waits for requests"}),"\n",(0,i.jsx)(n.li,{children:"Client connects to the service and sends requests"}),"\n",(0,i.jsx)(n.li,{children:"Server processes requests and sends responses back to client"}),"\n"]})]})]}),"\n",(0,i.jsx)(n.h3,{id:"example-2-action-server-and-client-for-humanoid-walking",children:"Example 2: Action Server and Client for Humanoid Walking"}),"\n",(0,i.jsxs)(o.A,{children:[(0,i.jsx)(a.A,{value:"action_def",label:"Action Definition (.action)",default:!0,children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"# File: action/WalkToPose.action\n# Goal\ngeometry_msgs/Pose target_pose\nfloat64 step_size\nint32 max_steps\n---\n# Result\nbool success\nstring message\nint32 steps_taken\ngeometry_msgs/Pose final_pose\n---\n# Feedback\nfloat32 progress_percentage\ngeometry_msgs/Pose current_pose\nstring status\nint32 steps_completed\n"})})}),(0,i.jsx)(a.A,{value:"action_server",label:"Action Server",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Example: Action server for humanoid robot walking to a pose\n\nimport rclpy\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.node import Node\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom rclpy.executors import MultiThreadedExecutor\nimport time\nimport math\nfrom geometry_msgs.msg import Pose, Point, Quaternion\nfrom builtin_interfaces.msg import Duration\n\n\nclass WalkToPoseActionServer(Node):\n    """\n    An action server that handles walking to a target pose for a humanoid robot.\n    Demonstrates action server implementation with feedback and cancellation.\n    """\n\n    def __init__(self):\n        super().__init__(\'walk_to_pose_action_server\')\n\n        # Use a reentrant callback group to handle multiple callbacks\n        callback_group = ReentrantCallbackGroup()\n\n        # Create the action server\n        self._action_server = ActionServer(\n            self,\n            WalkToPose,  # This would be imported from your action definition\n            \'walk_to_pose\',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=callback_group\n        )\n\n        # Current robot pose (simulated)\n        self.current_pose = Pose()\n        self.current_pose.position.x = 0.0\n        self.current_pose.position.y = 0.0\n        self.current_pose.position.z = 0.0\n        self.current_pose.orientation.w = 1.0\n\n        self.get_logger().info(\'Walk To Pose Action Server initialized\')\n\n    def goal_callback(self, goal_request):\n        """Accept or reject goal requests."""\n        # Check if the goal is reasonable (e.g., not too far away)\n        distance = math.sqrt(\n            (goal_request.target_pose.position.x - self.current_pose.position.x)**2 +\n            (goal_request.target_pose.position.y - self.current_pose.position.y)**2\n        )\n\n        if distance > 10.0:  # Max distance of 10 meters\n            self.get_logger().warn(f\'Rejecting goal: too far away ({distance:.2f}m)\')\n            return GoalResponse.REJECT\n\n        self.get_logger().info(f\'Accepting goal to walk to ({goal_request.target_pose.position.x:.2f}, {goal_request.target_pose.position.y:.2f})\')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        """Accept or reject cancel requests."""\n        self.get_logger().info(\'Received cancel request for walk action\')\n        return CancelResponse.ACCEPT\n\n    async def execute_callback(self, goal_handle):\n        """Execute the walk action."""\n        self.get_logger().info(\'Executing walk to pose action...\')\n\n        # Get goal parameters\n        target_pose = goal_handle.request.target_pose\n        step_size = goal_handle.request.step_size\n        max_steps = goal_handle.request.max_steps\n\n        # Calculate distance to target\n        distance = math.sqrt(\n            (target_pose.position.x - self.current_pose.position.x)**2 +\n            (target_pose.position.y - self.current_pose.position.y)**2\n        )\n\n        # Calculate number of steps needed\n        steps_needed = int(distance / step_size) + 1\n        total_steps = min(steps_needed, max_steps)\n\n        # Simulate walking progress\n        for step in range(total_steps):\n            # Check if the goal was cancelled\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                result = WalkToPose.Result()\n                result.success = False\n                result.message = \'Goal was canceled\'\n                result.steps_taken = step\n                result.final_pose = self.current_pose\n                return result\n\n            # Simulate taking a step\n            progress = float(step) / float(total_steps)\n            self.current_pose.position.x += (target_pose.position.x - self.current_pose.position.x) * (1.0 / total_steps)\n            self.current_pose.position.y += (target_pose.position.y - self.current_pose.position.y) * (1.0 / total_steps)\n\n            # Update feedback\n            feedback_msg = WalkToPose.Feedback()\n            feedback_msg.progress_percentage = progress * 100.0\n            feedback_msg.current_pose = self.current_pose\n            feedback_msg.status = f\'Walking... Step {step+1}/{total_steps}\'\n            feedback_msg.steps_completed = step + 1\n\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f\'Feedback: {feedback_msg.status} ({feedback_msg.progress_percentage:.1f}%)\')\n\n            # Simulate time for each step\n            time.sleep(0.5)\n\n        # Check if we reached the target\n        distance_to_target = math.sqrt(\n            (target_pose.position.x - self.current_pose.position.x)**2 +\n            (target_pose.position.y - self.current_pose.position.y)**2\n        )\n\n        # Create result\n        result = WalkToPose.Result()\n        if distance_to_target <= step_size:  # Consider successful if within step size\n            result.success = True\n            result.message = f\'Successfully walked to target in {total_steps} steps\'\n            result.steps_taken = total_steps\n            result.final_pose = self.current_pose\n            goal_handle.succeed()\n        else:\n            result.success = False\n            result.message = f\'Failed to reach target after {total_steps} steps\'\n            result.steps_taken = total_steps\n            result.final_pose = self.current_pose\n            goal_handle.abort()\n\n        self.get_logger().info(f\'Action completed: {result.message}\')\n        return result\n\n\ndef main(args=None):\n    """Main function to run the action server."""\n    rclpy.init(args=args)\n\n    node = WalkToPoseActionServer()\n\n    # Use a multi-threaded executor to handle callbacks\n    executor = MultiThreadedExecutor()\n    executor.add_node(node)\n\n    try:\n        executor.spin()\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})})}),(0,i.jsx)(a.A,{value:"action_client",label:"Action Client",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'#!/usr/bin/env python3\n# Example: Action client for humanoid robot walking to a pose\n\nimport rclpy\nfrom rclpy.action import ActionClient\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Pose, Point, Quaternion\nimport time\n\n\nclass WalkToPoseActionClient(Node):\n    """\n    An action client that sends walk commands to the humanoid robot.\n    Demonstrates action client implementation with feedback handling.\n    """\n\n    def __init__(self):\n        super().__init__(\'walk_to_pose_action_client\')\n\n        # Create the action client\n        self._action_client = ActionClient(self, WalkToPose, \'walk_to_pose\')\n\n    def send_goal(self, x, y, step_size=0.1, max_steps=100):\n        """Send a goal to the action server."""\n        # Wait for the action server to be available\n        self.get_logger().info(\'Waiting for action server...\')\n        self._action_client.wait_for_server()\n\n        # Create the goal message\n        goal_msg = WalkToPose.Goal()\n        goal_msg.target_pose = Pose()\n        goal_msg.target_pose.position.x = x\n        goal_msg.target_pose.position.y = y\n        goal_msg.target_pose.position.z = 0.0\n        goal_msg.target_pose.orientation.w = 1.0\n        goal_msg.step_size = step_size\n        goal_msg.max_steps = max_steps\n\n        # Send the goal\n        self.get_logger().info(f\'Sending goal to walk to ({x}, {y})\')\n        send_goal_future = self._action_client.send_goal_async(\n            goal_msg,\n            feedback_callback=self.feedback_callback\n        )\n\n        # Wait for the response\n        rclpy.spin_until_future_complete(self, send_goal_future)\n        goal_handle = send_goal_future.result()\n\n        if not goal_handle.accepted:\n            self.get_logger().error(\'Goal was rejected by the server\')\n            return None\n\n        self.get_logger().info(\'Goal accepted by server, waiting for result...\')\n        get_result_future = goal_handle.get_result_async()\n\n        # Wait for the result\n        rclpy.spin_until_future_complete(self, get_result_future)\n        result = get_result_future.result().result\n\n        self.get_logger().info(f\'Action completed: {result.message}\')\n        return result\n\n    def feedback_callback(self, feedback_msg):\n        """Handle feedback from the action server."""\n        feedback = feedback_msg.feedback\n        self.get_logger().info(\n            f\'Feedback: {feedback.status} - Progress: {feedback.progress_percentage:.1f}%\'\n        )\n\n\ndef main(args=None):\n    """Main function to run the action client."""\n    rclpy.init(args=args)\n\n    action_client = WalkToPoseActionClient()\n\n    # Send a goal to walk to position (2.0, 1.0)\n    result = action_client.send_goal(2.0, 1.0, step_size=0.2, max_steps=50)\n\n    if result and result.success:\n        print(f"Successfully walked to target! Final pose: ({result.final_pose.position.x:.2f}, {result.final_pose.position.y:.2f})")\n    else:\n        print("Failed to walk to target")\n\n    action_client.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == \'__main__\':\n    main()\n'})})})]}),"\n",(0,i.jsx)(n.h2,{id:"exercises-and-checkpoints",children:"Exercises and Checkpoints"}),"\n",(0,i.jsx)(n.h3,{id:"exercise-1-service-vs-action-decision-matrix",children:"Exercise 1: Service vs Action Decision Matrix"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Scenario:"})," You're designing a humanoid robot control system with these operations:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Query current battery level"}),"\n",(0,i.jsx)(n.li,{children:"Move robot to a specific location"}),"\n",(0,i.jsx)(n.li,{children:"Calibrate joint encoders"}),"\n",(0,i.jsx)(n.li,{children:"Request robot to play a sound"}),"\n",(0,i.jsx)(n.li,{children:"Perform a complex manipulation task"}),"\n",(0,i.jsx)(n.li,{children:"Get current joint positions"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Task:"})," For each operation, decide whether to use a topic, service, or action, and justify your choice."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Success Criteria:"})}),"\n",(0,i.jsxs)(n.ul,{className:"contains-task-list",children:["\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Correctly identify which pattern to use for each operation"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Provide clear justification based on communication requirements"]}),"\n",(0,i.jsxs)(n.li,{className:"task-list-item",children:[(0,i.jsx)(n.input,{type:"checkbox",disabled:!0})," ","Consider timing, feedback, and cancellation needs"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"exercise-2-practical-implementation",children:"Exercise 2: Practical Implementation"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Objective:"})," Create a service that allows external systems to request the humanoid robot to perform a simple behavior (e.g., wave arms)."]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Steps:"})}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Define a custom service type for the waving behavior"}),"\n",(0,i.jsx)(n.li,{children:"Implement a service server that simulates the waving motion"}),"\n",(0,i.jsx)(n.li,{children:"Create a service client that calls the service"}),"\n",(0,i.jsx)(n.li,{children:"Add error handling for invalid requests"}),"\n",(0,i.jsx)(n.li,{children:"Test the service with different parameters"}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Expected Outcome:"})," Working service with proper error handling and validation."]}),"\n",(0,i.jsx)(n.h3,{id:"self-assessment-questions",children:"Self-Assessment Questions"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," What is the main difference between a service and an action in ROS 2?\n",(0,i.jsx)(n.strong,{children:"Answer:"})," Services provide simple request-response communication for quick operations, while actions are designed for long-running tasks that need feedback during execution and the ability to cancel."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," When should you use an action instead of a service?\n",(0,i.jsx)(n.strong,{children:"Answer:"})," Use actions for tasks that take significant time to complete, need to provide progress feedback, or should be cancellable. Use services for quick operations that return a result immediately."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Question:"})," What are the three message types in an action definition?\n",(0,i.jsx)(n.strong,{children:"Answer:"})," Goal (input parameters), Result (final output), and Feedback (intermediate status updates)."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"summary-and-key-takeaways",children:"Summary and Key Takeaways"}),"\n",(0,i.jsx)(n.h3,{id:"key-concepts-recap",children:"Key Concepts Recap"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Services"}),": Synchronous request-response communication for quick operations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Actions"}),": Asynchronous communication for long-running tasks with feedback and cancellation"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Service Definitions"}),": .srv files that define request and response message types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Action Definitions"}),": .action files that define goal, result, and feedback message types"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Client-Server Pattern"}),": Clear separation between requesters and implementers"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"practical-applications",children:"Practical Applications"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Services"}),": Querying robot state, enabling/disabling functions, loading configurations"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Actions"}),": Navigation, manipulation, calibration, complex behaviors with progress tracking"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Proper response messages and exception handling for robust systems"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Asynchronous Operations"}),": Non-blocking communication for responsive robot systems"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Module Progression:"})," Next chapter covers ",(0,i.jsx)(n.a,{href:"/Physical-AI-Humanoid-Robotics-Book/docs/module-1-ros2/urdf-modeling",children:"URDF Modeling"})," for robot description"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Further Reading:"})," Explore advanced action features like preemption and multiple goals"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Practice Opportunities:"})," Implement services and actions for different robot subsystems"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"common-mistakes-and-troubleshooting",children:"Common Mistakes and Troubleshooting"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mistake 1:"})," Using services for long-running operations \u2192 ",(0,i.jsx)(n.strong,{children:"Solution:"})," Use actions for tasks that take significant time"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mistake 2:"})," Not handling cancellation in action servers \u2192 ",(0,i.jsx)(n.strong,{children:"Solution:"})," Always check for cancellation requests in action execution loops"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Mistake 3:"})," Blocking service callbacks \u2192 ",(0,i.jsx)(n.strong,{children:"Solution:"})," Keep service callbacks fast and handle heavy processing asynchronously"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"references-and-resources",children:"References and Resources"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Services/Understanding-ROS2-Services.html",children:"ROS 2 Services Tutorial"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Tutorials/Actions/Understanding-ROS2-Actions.html",children:"ROS 2 Actions Guide"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros.org/en/humble/Concepts/About-ROS-Interfaces.html#action-definition-files",children:"Action Definition Files"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"https://docs.ros2.org/latest/api/rclpy/api/actions.html",children:"rclpy Action Documentation"})}),"\n"]})]})}function g(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}}}]);